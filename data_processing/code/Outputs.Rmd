---
title: "Outputs"
author: "Valentin"
date: "`r Sys.Date()`"
output: 
  html_document:
      self_contained: false
---

# Set up and inputs
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(aws.s3)
aws.signature::use_credentials()
Sys.setenv("AWS_DEFAULT_REGION" = "eu-west-1")


library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)
library(here)
library(tictoc)
library(readstata13)
library(sjmisc)
library(terra) # put it after {raster} such that it superceeds homonym functions. 
library(exactextractr)
library(stars)
library(pals)
library(modelsummary) # necessary to load it after DescTools

library(biscale)
library(cowplot)
library(viridis)

set.seed(8888)

# install.packages("https://cran.r-project.org/src/contrib/Archive/isotree/isotree_0.5.5.tar.gz",
#                  repos = NULL, 
#                  type = "source")

# Storage directories
dir.create(here("outputs", "aggregate_sheds"), recursive = TRUE)


## Functions
# Trase palettes etc. for plots
source(here("code", "theme_trase.R"))

# load in particular the function fn_trader_to_group_names, str_trans, ... 
source(here("code", "USEFUL_STUFF_supplyshedproj.R"))

# use the projected CRS used by BNETD for their 2020 land use map. 
civ_crs <- 32630

MODEL_RESOLUTION_KM = 4
cell_area_ha =(100*MODEL_RESOLUTION_KM^2)

xlabs = c(-8, -6, -4)
ylabs = c(5, 7, 9)

## Assets

departements <- read_sf(here("input_data/s3/CIV_DEPARTEMENTS.geojson"))
departements = 
  st_transform(departements, crs = civ_crs)

coopbsy = read.csv(file = here("temp_data/private_IC2B/IC2B_v2_coop_bs_year.csv"))
coopbs22 = coopbsy %>% filter(YEAR == 2022)

coopbs22_sf = 
  coopbs22 %>% 
  filter(!is.na(LONGITUDE)) %>% 
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326)

links = readRDS(here("temp_data", "model", paste0("links.Rdata")))

cells = readRDS(here("temp_data", "model", paste0("cells_topredict.Rdata"))) 

# Useful variables 
cells = 
  cells %>% 
  mutate(
    CELL_NODEF_EXPANSION_HA = 
           1600
         - CELL_COCOA_HA
         - CELL_DENSEFOREST_HA
         - CELL_OTHERFORESTS_HA
         - CELL_IMPOSSIBLE_HA, 
    CELL_FOREST_HA = CELL_DENSEFOREST_HA + CELL_OTHERFORESTS_HA,
    CELL_ALL_CD_HA = CELL_OLD_CD_HA + CELL_REC_CD_HA,
    CELL_1minusSHARE_COOP = 1 - CELL_SHARE_COOP) 

```

## Transformations for display
```{r}
cells_toplot = 
  cells %>% 
  mutate(
   # Work on PERCENTAGE, not share, from here, for display. 
    CELL_SHARE_COOP = 100*CELL_SHARE_COOP,
    CELL_COCOA_SHARE = 100*CELL_COCOA_SHARE, 
    # Round hectares
    across(.cols = ends_with("_HA"), .fns = ~.x/1000), # replaces all the variables ending with _HA
    across(.cols = ends_with("_HA"), .fns = ~round(.x, 1)) 
    # across(.cols = ends_with("_HA"), .fns = ~round(.x, 0)), 
    )
names(cells_toplot) <- gsub("_HA", "_KHA", names(cells_toplot))
summary(cells$CELL_COCOA_HA)
summary(cells_toplot$CELL_COCOA_KHA)

# Just add it back for deforestation
cells_toplot = cells_toplot %>% left_join(cells %>% select(CELL_ID, CELL_ALL_CD_HA), by = "CELL_ID")


```


# Aggregate sourcing sheds 
This uses mostly first stage results. 

## Outside vs. Within

### Aggregate numbers

```{r}
# The area of each LU category WITHIN the aggregate sourcing shed: 
fn_aggregate_lu = function(out_or_in_share){
  cells %>%
  summarise(.by = CELL_IS_IN_AOA, # this is to summarise over all obs, because non-AOA cells have been remove in previous script already.
            `N CELLS` = sum({{out_or_in_share}}>0), # this will probably be removed eventually
            TOTAL          = round(sum({{out_or_in_share}}*1600) / 1000, 1),
            COCOA          = round(sum({{out_or_in_share}}*CELL_COCOA_HA) / 1000, 1),
            FOREST         = round(sum({{out_or_in_share}}*CELL_FOREST_HA) / 1000, 1),
            `DENSE FOREST` = round(sum({{out_or_in_share}}*CELL_DENSEFOREST_HA) / 1000, 1),
            `OTHER FOREST` = round(sum({{out_or_in_share}}*CELL_OTHERFORESTS_HA) / 1000, 1),
            `AVAILABLE, NOT FORESTED LAND` = round(sum({{out_or_in_share}}*CELL_NODEF_EXPANSION_HA) / 1000, 1), 
            `COCOA DEFORESTATION`          = round(sum({{out_or_in_share}}*CELL_ALL_CD_HA) / 1000, 1)
            ) %>% 
  filter(CELL_IS_IN_AOA) %>% 
  select(-CELL_IS_IN_AOA)
}

fn_aggregate_lu_relative = function(out_or_in_share){
  cells %>%
  summarise(.by = CELL_IS_IN_AOA, 
            `N CELLS` = "", # this will probably be removed eventually
            TOTAL          = 100*round(sum({{out_or_in_share}}*1600) / (1600*nrow(cells)), 2),
            COCOA          = 100*round(sum({{out_or_in_share}}*CELL_COCOA_HA) / sum(CELL_COCOA_HA), 2),
            FOREST         = 100*round(sum({{out_or_in_share}}*CELL_FOREST_HA) / sum(CELL_FOREST_HA), 1),
            `DENSE FOREST` = 100*round(sum({{out_or_in_share}}*CELL_DENSEFOREST_HA) / sum(CELL_DENSEFOREST_HA), 2),
            `OTHER FOREST` = 100*round(sum({{out_or_in_share}}*CELL_OTHERFORESTS_HA) / sum(CELL_OTHERFORESTS_HA), 2),
            `AVAILABLE, NOT FORESTED LAND` = 100*round(sum({{out_or_in_share}}*CELL_NODEF_EXPANSION_HA) / sum(CELL_NODEF_EXPANSION_HA), 2),
            `COCOA DEFORESTATION`          = 100*round(sum({{out_or_in_share}}*CELL_ALL_CD_HA) / sum(CELL_ALL_CD_HA), 2)
            ) %>% 
  filter(CELL_IS_IN_AOA) %>% 
  select(-CELL_IS_IN_AOA)
}

aggr_tbl = 
  rbind(
    fn_aggregate_lu(CELL_SHARE_COOP) %>% 
      mutate(` ` = "Within (kha)", .before = everything()),
    fn_aggregate_lu_relative(CELL_SHARE_COOP) %>% 
      mutate(` ` = "Within (%)", .before = everything()),
    fn_aggregate_lu(CELL_1minusSHARE_COOP) %>% 
      mutate(` ` = "Outside (kha)", .before = everything())
  )
  
aggr_tbl

out_tbl = 
  aggr_tbl %>% 
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
  # row_spec(12, extra_css = "padding-left: 20px;")

out_tbl

save_kable(out_tbl, here("outputs", "aggregate_sheds", "LU_in_out.png"))

```


### Univariate map
Decide to have 3 or 4 bins in the end, based on final data. 
```{r}
# cells_toplot$CELL_COCOA_SHARE %>% summary()
# cells_toplot$CELL_COCOA_HA %>% summary()
# cells_toplot$CELL_SHARE_COOP %>% summary()
# cells_toplot$CELL_SHARE_COOP %>% quantile(seq(0, 1, 0.1), na.rm = T)

cells_toplot = 
  cells_toplot %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs) 

# Max share of coop outlet, rounded up for clean display
max_share_coop = round(max(cells_toplot$CELL_SHARE_COOP, na.rm = TRUE)+5,-1)

# Depending on final results, choose to show in 3 or 4 bins
break_values = c(0,15,45,max_share_coop)
bin_names = c("0-15%", "15-45%", paste0("45-",max_share_coop,"%"))

# Custom breaks bc we want the lowest bin to be 0 only. 
cells_toplot$`Cooperative outlet (%)` = 
  cut(cells_toplot$CELL_SHARE_COOP, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      include.lowest = TRUE,
      breaks = break_values, 
      labels = bin_names
      )

cells_toplot$`Cooperative outlet (%)` %>% table()

# Make palette with same colors as in the bivariate map
uni_in_bi_pal_outlet = 
  bi_pal("BlueOr", dim = 3, preview = F)
uni_in_bi_pal_outlet = uni_in_bi_pal_outlet[grepl("1-", names(uni_in_bi_pal_outlet))]
names(uni_in_bi_pal_outlet) = bin_names
uni_in_bi_pal_outlet

map =
  ggplot(cells_toplot) +
  geom_sf(mapping = aes(fill = `Cooperative outlet (%)`, col = `Cooperative outlet (%)`),
          size = 1, shape = 22) + #
  scale_fill_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  scale_colour_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  
   # geom_sf(mapping = aes(fill = CELL_SHARE_COOP, col = CELL_SHARE_COOP), 
   #        size = 1, shape = 22) + # 
  
  geom_sf(data = coopbs22_sf, col = "black", size = 0.7) +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Cooperative outlet",
    subtitle = ""
  ) 

map

ggsave(
  plot = map,
  filename = paste0("cooperative_outlet.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 25,
  height = 20,
  units = "cm")
```



### Bivariate maps
Use biscale package. Different vignettes, including on available bivariate palettes here: 
https://cran.r-project.org/web/packages/biscale/index.html

Use palettes with blue: BlueGold, BlueYl (similar), BlueOr, DkViolet2

#### Cocoa x share
BlueYl
```{r}
cells_toplot$CELL_COCOA_KHA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_COCOA_KHA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_COCOA_KHA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "BlueYl", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "BlueYl", dim = 3, na.value = "transparent") +
  # labs(
  #   title = "Cooperative outlet and cocoa extent",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "BlueYl",
                    dim = 3,
                    xlab = "Cocoa farms (kha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)
# element_text(
#   face = "bold",
#   size = 10
#       ), 
                    
cocoa_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

cocoa_bivplot

ggsave(
  plot = cocoa_bivplot,
  filename = paste0("cocoa_bivplot.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 25,
  height = 20,
  units = "cm")

```

#### Forest x share
BlueOr
```{r}
cells_toplot$CELL_FOREST_KHA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_FOREST_KHA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_FOREST_KHA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "BlueOr", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "BlueOr", dim = 3, na.value = "transparent") +
  # labs(
  #   title = "Cooperative outlet and forest extent",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "BlueOr",
                    dim = 3,
                    xlab = "Forested land (kha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

forest_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

forest_bivplot
```

#### Potentially sustainable x share
DkViolet2
```{r}
cells_toplot$CELL_NODEF_EXPANSION_KHA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_NODEF_EXPANSION_KHA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_NODEF_EXPANSION_KHA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "DkCyan2", dim = 3, na.value = "transparent", flip_axes = TRUE) +
  bi_scale_color(pal = "DkCyan2", dim = 3, na.value = "transparent", flip_axes = TRUE) +
  # labs(
  #   title = "Cooperative outlet and land for potentially sustainable cocoa expansion",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "DkCyan2",
                    dim = 3,
                    flip_axes = TRUE,
                    xlab = "Available land (kha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

avb_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

avb_bivplot
```

#### Multi-panel plot
```{r}
multipanel_bivplot = 
  ggarrange(
    cocoa_bivplot, 
    forest_bivplot,
    avb_bivplot,
    ncol = 3, nrow = 1, 
    common.legend = FALSE, 
    labels = c("COCOA EXTENT", "FOREST EXTENT", 
               "POTENTIAL LAND FOR SUSTAINABLE COCOA"), 
    hjust = c(-0.5, -0.5, 0), 
    font.label = list(size = 16, color = "black", face = "bold", family = NULL)
    # align = "h"
  ) %>% 
    annotate_figure(top = text_grob("COOPERATIVE OUTLET & ...\n", face = "bold", size = 18))

multipanel_bivplot

ggsave(
  plot = multipanel_bivplot,
  filename = paste0("multipanel_bivplot.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 75,
  height = 50,
  units = "cm")

```

#### Past CD x share
Bluegill
```{r}
cells_toplot$CELL_ALL_CD_HA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_ALL_CD_HA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
            dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_ALL_CD_HA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")
breaks$bi_x = breaks$bi_x %>% round(0)

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "GrPink2", dim = 3, na.value = "transparent", flip_axes = FALSE) +
  bi_scale_color(pal = "GrPink2", dim = 3, na.value = "transparent", flip_axes = FALSE) +
  labs(
    title = "PAST COCOA DEFORESTATION",
  ) +
  bi_theme()  + 
    theme(plot.title = element_text(size = 16)) 

legend <- bi_legend(pal = "GrPink2",
                    flip_axes = FALSE,
                    dim = 3,
                    xlab = "Cocoa deforestation (ha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

pastcd_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.1, 1, 0.9) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.25, height = 0.25)

pastcd_bivplot

# ggsave(
#   plot = pastcd_bivplot,
#   filename = paste0("pastcd_bivplot.png"),
#   path = here("outputs", "aggregate_sheds"),
#   width = 25,
#   height = 20,
#   units = "cm")
```









## Exclusive vs. Shared
Use same coding as above, but with different bins and palettes  


# Individual sourcing sheds

## Hotspots


## Heuristics

# Additional stuff 
## Distance map

```{r}
cells_toplot = 
  cells_toplot %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs) 

cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS %>% summary()
# Max share of coop outlet, rounded up for clean display
max_dist = round(max(cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS, na.rm = TRUE)+5,-1)

# Depending on final results, choose to show in 3 or 4 bins
bin_names = c("0-15km", "15-45km", paste0("45-",max_dist,"km"))

# Custom breaks bc we want the lowest bin to be 0 only. 
cells_toplot$`Avg. distance 5 nearest coops (m)` = 
  cut(cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      include.lowest = TRUE,
      breaks = c(0,15000,45000,max_dist), 
      labels = bin_names
      )

cells_toplot$`Avg. distance 5 nearest coops (m)` %>% table()

# Make palette with same colors as in the bivariate map
uni_in_bi_pal_outlet = 
  bi_pal("PurpleOr", dim = 3, preview = F)
uni_in_bi_pal_outlet = uni_in_bi_pal_outlet[grepl("1-", names(uni_in_bi_pal_outlet))]
names(uni_in_bi_pal_outlet) = bin_names
uni_in_bi_pal_outlet

map =
  ggplot(cells_toplot) +
  geom_sf(mapping = aes(fill = `Avg. distance 5 nearest coops (m)`, col = `Avg. distance 5 nearest coops (m)`),
          size = 1, shape = 22) + #
  scale_fill_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  scale_colour_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  
   # geom_sf(mapping = aes(fill = CELL_SHARE_COOP, col = CELL_SHARE_COOP), 
   #        size = 1, shape = 22) + # 
  
  geom_sf(data = coopbs22_sf, col = "black", size = 0.7) +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Distance to cooperatives",
    subtitle = ""
  ) 

map

```


# Old Stuff
### Discrete map 
```{r}
# Make cell categories
# keep in mind that the purpose of this is a map, not an analysis! 

# Start from link level
links = 
  links %>% 
  mutate(
    CELL_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0, 
     # This is where no cocoa is estimated to be sold to coops, but independent of that, some links with coops are predicted to exist (they pass the threshold). 
    CELL_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0, 
    
    # Productive sourcing sheds: actual, influential and outside 
    CELL_PRODUCTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE",
    CELL_PRODUCTIVE_OUTSIDE = CELL_SHARE_COOP == 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    
    # Prospective sourcing sheds: actual, influential and outside 
    CELL_PROSPECTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_OUTSIDE = CELL_SHARE_COOP == 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 

    
    `Sourcing shed type` = case_when(
      CELL_PRODUCTIVE_SOURCING_SHED_ONLY ~ "Productive, actual",
      CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY ~ "Productive, influential", 
      CELL_PRODUCTIVE_OUTSIDE ~ "Productive, outside",
      CELL_PROSPECTIVE_SOURCING_SHED_ONLY ~ "Prospective, actual",
      CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY ~ "Prospective, influential", 
      CELL_PROSPECTIVE_OUTSIDE ~ "Prospective, outside",

      TRUE ~ NA
    )
    )

# links %>% 
#   filter(is.na(`Sourcing shed type`)) %>% 
#   select(CELL_PRODUCTIVE_SOURCING_SHED_ONLY, CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY, CELL_PROSPECTIVE_SOURCING_SHED_ONLY, CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY) %>% 
#   summary()

cells = 
  cells %>% 
  left_join(
    links %>% select(CELL_ID, `Sourcing shed type`) %>% distinct(CELL_ID, .keep_all = TRUE), 
    by = "CELL_ID", multiple = "all"
  )
cells$`Sourcing shed type` %>% table()

# Check that we cover all cells we predicted a coop outlet share (i.e. excluding not in AoA)
stopifnot(
cells %>% filter(!is.na(CELL_SHARE_COOP)) %>% nrow() == sum(table(cells$`Sourcing shed type`))
)
```

A discrete map may be misleading though, as it may represent many cells in the actual sourcing shed, while their predicted shares of coop outlet are small and uncertain. 


