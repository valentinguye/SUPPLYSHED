---
title: "Outputs"
author: "Valentin"
date: "`r Sys.Date()`"
output: 
  html_document:
      self_contained: false
---

# Set up and inputs
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(aws.s3)
aws.signature::use_credentials()
Sys.setenv("AWS_DEFAULT_REGION" = "eu-west-1")


library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)
library(here)
library(tictoc)
library(readstata13)
library(sjmisc)
library(terra) # put it after {raster} such that it superceeds homonym functions. 
library(exactextractr)
library(stars)
library(pals)
library(modelsummary) # necessary to load it after DescTools

library(biscale)
library(cowplot)
library(viridis)
library(bubbles)

set.seed(8888)

# install.packages("https://cran.r-project.org/src/contrib/Archive/isotree/isotree_0.5.5.tar.gz",
#                  repos = NULL, 
#                  type = "source")

# Storage directories
dir.create(here("outputs", "aggregate_sheds"), recursive = TRUE)


## Functions
# Trase palettes etc. for plots
source(here("code", "theme_trase.R"))

# load in particular the function fn_trader_to_group_names, str_trans, ... 
source(here("code", "USEFUL_STUFF_supplyshedproj.R"))

# use the projected CRS used by BNETD for their 2020 land use map. 
civ_crs <- 32630

MODEL_RESOLUTION_KM = 4
cell_area_ha =(100*MODEL_RESOLUTION_KM^2)

xlabs = c(-8, -6, -4)
ylabs = c(5, 7, 9)

## Assets

departements <- read_sf(here("input_data/s3/CIV_DEPARTEMENTS.geojson"))
departements = 
  st_transform(departements, crs = civ_crs)

coopbsy = read.csv(file = here("temp_data/private_IC2B/IC2B_v2_coop_bs_year.csv"))

coopbs22 = coopbsy %>% filter(YEAR == 2022) %>% 
  # do that to match the output of the model 
  mutate(COOP_ID = paste0("COOP-",COOP_ID)) 

coopbs22_sf = 
  coopbs22 %>% 
  filter(!is.na(LONGITUDE)) %>% 
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326)

coopbs22_sf$COOP_ID %>% unique()%>% length() 

links = readRDS(here("temp_data", "model", paste0("links_topredict.Rdata")))

cells = readRDS(here("temp_data", "model", paste0("cells_topredict.Rdata"))) 

# Useful variables 
cells = 
  cells %>% 
  mutate(
    CELL_NODEF_EXPANSION_HA = 
           cell_area_ha
         - CELL_COCOA_HA
         - CELL_DENSEFOREST_HA
         - CELL_OTHERFORESTS_HA
         - CELL_IMPOSSIBLE_HA, 
    CELL_FOREST_HA = CELL_DENSEFOREST_HA + CELL_OTHERFORESTS_HA,
    CELL_ALL_CD_HA = CELL_OLD_CD_HA + CELL_REC_CD_HA,
    CELL_1minusSHARE_COOP = 1 - CELL_SHARE_COOP) 

```

## Transformations for display
```{r}
cells_toplot = 
  cells %>% 
  mutate(
   # Work on PERCENTAGE, not share, from here, for display. 
    CELL_SHARE_COOP = 100*CELL_SHARE_COOP,
    CELL_COCOA_SHARE = 100*CELL_COCOA_SHARE, 
    # Round hectares
    across(.cols = ends_with("_HA"), .fns = ~.x/1000), # replaces all the variables ending with _HA
    across(.cols = ends_with("_HA"), .fns = ~round(.x, 1)) 
    # across(.cols = ends_with("_HA"), .fns = ~round(.x, 0)), 
    )
names(cells_toplot) <- gsub("_HA", "_KHA", names(cells_toplot))
summary(cells$CELL_COCOA_HA)
summary(cells_toplot$CELL_COCOA_KHA)

# Just add it back for deforestation
cells_toplot = cells_toplot %>% left_join(cells %>% select(CELL_ID, CELL_ALL_CD_HA), by = "CELL_ID")


```
# Descriptive statistics
## Development/prediction balance tests
 
```{r}

```

# B. Explanation
All things variable importance and explanation here. 



# C. Aggregate sourcing sheds 
This uses mostly first stage results. 

## Outside vs. Within

### Aggregate numbers

```{r}
# The area of each LU category WITHIN the aggregate sourcing shed: 
fn_aggregate_lu = function(out_or_in_share){
  cells %>%
  summarise(.by = CELL_IS_IN_AOA, # this is to summarise over all obs, because non-AOA cells have been remove in previous script already.
            `N CELLS` = sum({{out_or_in_share}}>0), # this will probably be removed eventually
            TOTAL          = round(sum({{out_or_in_share}}*cell_area_ha) / 1000, 1),
            COCOA          = round(sum({{out_or_in_share}}*CELL_COCOA_HA) / 1000, 1),
            FOREST         = round(sum({{out_or_in_share}}*CELL_FOREST_HA) / 1000, 1),
            `DENSE FOREST` = round(sum({{out_or_in_share}}*CELL_DENSEFOREST_HA) / 1000, 1),
            `OTHER FOREST` = round(sum({{out_or_in_share}}*CELL_OTHERFORESTS_HA) / 1000, 1),
            `AVAILABLE, NOT FORESTED LAND` = round(sum({{out_or_in_share}}*CELL_NODEF_EXPANSION_HA) / 1000, 1), 
            `COCOA DEFORESTATION`          = round(sum({{out_or_in_share}}*CELL_ALL_CD_HA) / 1000, 1)
            ) %>% 
  filter(CELL_IS_IN_AOA) %>% 
  select(-CELL_IS_IN_AOA)
}

fn_aggregate_lu_relative = function(out_or_in_share){
  cells %>%
  summarise(.by = CELL_IS_IN_AOA, 
            `N CELLS` = "", # this will probably be removed eventually
            TOTAL          = 100*round(sum({{out_or_in_share}}*cell_area_ha) / (cell_area_ha*nrow(cells)), 2),
            COCOA          = 100*round(sum({{out_or_in_share}}*CELL_COCOA_HA) / sum(CELL_COCOA_HA), 2),
            FOREST         = 100*round(sum({{out_or_in_share}}*CELL_FOREST_HA) / sum(CELL_FOREST_HA), 1),
            `DENSE FOREST` = 100*round(sum({{out_or_in_share}}*CELL_DENSEFOREST_HA) / sum(CELL_DENSEFOREST_HA), 2),
            `OTHER FOREST` = 100*round(sum({{out_or_in_share}}*CELL_OTHERFORESTS_HA) / sum(CELL_OTHERFORESTS_HA), 2),
            `AVAILABLE, NOT FORESTED LAND` = 100*round(sum({{out_or_in_share}}*CELL_NODEF_EXPANSION_HA) / sum(CELL_NODEF_EXPANSION_HA), 2),
            `COCOA DEFORESTATION`          = 100*round(sum({{out_or_in_share}}*CELL_ALL_CD_HA) / sum(CELL_ALL_CD_HA), 2)
            ) %>% 
  filter(CELL_IS_IN_AOA) %>% 
  select(-CELL_IS_IN_AOA)
}

aggr_tbl = 
  rbind(
    fn_aggregate_lu(CELL_SHARE_COOP) %>% 
      mutate(` ` = "Within (kha)", .before = everything()),
    fn_aggregate_lu_relative(CELL_SHARE_COOP) %>% 
      mutate(` ` = "Within (%)", .before = everything()),
    fn_aggregate_lu(CELL_1minusSHARE_COOP) %>% 
      mutate(` ` = "Outside (kha)", .before = everything())
  )
  
aggr_tbl

out_tbl = 
  aggr_tbl %>% 
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
  # row_spec(12, extra_css = "padding-left: 20px;")

out_tbl

save_kable(out_tbl, here("outputs", "aggregate_sheds", "LU_in_out.png"))

```


### Univariate map
Decide to have 3 or 4 bins in the end, based on final data. 
```{r}
# cells_toplot$CELL_COCOA_SHARE %>% summary()
# cells_toplot$CELL_COCOA_HA %>% summary()
# cells_toplot$CELL_SHARE_COOP %>% summary()
# cells_toplot$CELL_SHARE_COOP %>% quantile(seq(0, 1, 0.1), na.rm = T)

cells_toplot = 
  cells_toplot %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs) 

# Max share of coop outlet, rounded up for clean display
max_share_coop = round(max(cells_toplot$CELL_SHARE_COOP, na.rm = TRUE)+5,-1)

# Depending on final results, choose to show in 3 or 4 bins
break_values = c(0,15,45,max_share_coop)
bin_names = c("0-15%", "15-45%", paste0("45-",max_share_coop,"%"))

# Custom breaks bc we want the lowest bin to be 0 only. 
cells_toplot$`Cooperative outlet (%)` = 
  cut(cells_toplot$CELL_SHARE_COOP, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      include.lowest = TRUE,
      breaks = break_values, 
      labels = bin_names
      )

cells_toplot$`Cooperative outlet (%)` %>% table()

# Make palette with same colors as in the bivariate map
uni_in_bi_pal_outlet = 
  bi_pal("BlueOr", dim = 3, preview = F)
uni_in_bi_pal_outlet = uni_in_bi_pal_outlet[grepl("1-", names(uni_in_bi_pal_outlet))]
names(uni_in_bi_pal_outlet) = bin_names
uni_in_bi_pal_outlet

map =
  ggplot(cells_toplot) +
  geom_sf(mapping = aes(fill = `Cooperative outlet (%)`, col = `Cooperative outlet (%)`),
          size = 1, shape = 22) + #
  scale_fill_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  scale_colour_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  
   # geom_sf(mapping = aes(fill = CELL_SHARE_COOP, col = CELL_SHARE_COOP), 
   #        size = 1, shape = 22) + # 
  
  geom_sf(data = coopbs22_sf, col = "black", size = 0.7) +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Cooperative outlet",
    subtitle = ""
  ) 

map

ggsave(
  plot = map,
  filename = paste0("cooperative_outlet.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 25,
  height = 20,
  units = "cm")
```



### Bivariate maps
Use biscale package. Different vignettes, including on available bivariate palettes here: 
https://cran.r-project.org/web/packages/biscale/index.html

Use palettes with blue: BlueGold, BlueYl (similar), BlueOr, DkViolet2

#### Cocoa x share
BlueYl
```{r}
cells_toplot$CELL_COCOA_KHA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_COCOA_KHA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_COCOA_KHA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "BlueYl", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "BlueYl", dim = 3, na.value = "transparent") +
  # labs(
  #   title = "Cooperative outlet and cocoa extent",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "BlueYl",
                    dim = 3,
                    xlab = "Cocoa farms (kha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)
# element_text(
#   face = "bold",
#   size = 10
#       ), 
                    
cocoa_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

cocoa_bivplot

ggsave(
  plot = cocoa_bivplot,
  filename = paste0("cocoa_bivplot.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 25,
  height = 20,
  units = "cm")

```

#### Forest x share
BlueOr
```{r}
cells_toplot$CELL_FOREST_KHA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_FOREST_KHA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_FOREST_KHA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "BlueOr", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "BlueOr", dim = 3, na.value = "transparent") +
  # labs(
  #   title = "Cooperative outlet and forest extent",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "BlueOr",
                    dim = 3,
                    xlab = "Forested land (kha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

forest_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

forest_bivplot
```

#### Potentially sustainable x share
DkViolet2
```{r}
cells_toplot$CELL_NODEF_EXPANSION_KHA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_NODEF_EXPANSION_KHA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_NODEF_EXPANSION_KHA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "DkCyan2", dim = 3, na.value = "transparent", flip_axes = TRUE) +
  bi_scale_color(pal = "DkCyan2", dim = 3, na.value = "transparent", flip_axes = TRUE) +
  # labs(
  #   title = "Cooperative outlet and land for potentially sustainable cocoa expansion",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "DkCyan2",
                    dim = 3,
                    flip_axes = TRUE,
                    xlab = "Available land (kha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

avb_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

avb_bivplot
```

#### Multi-panel plot
```{r}
multipanel_bivplot = 
  ggarrange(
    cocoa_bivplot, 
    forest_bivplot,
    avb_bivplot,
    ncol = 3, nrow = 1, 
    common.legend = FALSE, 
    labels = c("COCOA EXTENT", "FOREST EXTENT", 
               "POTENTIAL LAND FOR SUSTAINABLE COCOA"), 
    hjust = c(-0.5, -0.5, 0), 
    font.label = list(size = 16, color = "black", face = "bold", family = NULL)
    # align = "h"
  ) %>% 
    annotate_figure(top = text_grob("COOPERATIVE OUTLET & ...\n", face = "bold", size = 18))

multipanel_bivplot

ggsave(
  plot = multipanel_bivplot,
  filename = paste0("multipanel_bivplot.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 75,
  height = 50,
  units = "cm")

```

#### Past CD x share
Bluegill
```{r}
cells_toplot$CELL_ALL_CD_HA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_ALL_CD_HA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
            dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_ALL_CD_HA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")
breaks$bi_x = breaks$bi_x %>% round(0)

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "GrPink2", dim = 3, na.value = "transparent", flip_axes = FALSE) +
  bi_scale_color(pal = "GrPink2", dim = 3, na.value = "transparent", flip_axes = FALSE) +
  labs(
    title = "PAST COCOA DEFORESTATION",
  ) +
  bi_theme()  + 
    theme(plot.title = element_text(size = 16)) 

legend <- bi_legend(pal = "GrPink2",
                    flip_axes = FALSE,
                    dim = 3,
                    xlab = "Cocoa deforestation (ha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

pastcd_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.1, 1, 0.9) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.25, height = 0.25)

pastcd_bivplot

# ggsave(
#   plot = pastcd_bivplot,
#   filename = paste0("pastcd_bivplot.png"),
#   path = here("outputs", "aggregate_sheds"),
#   width = 25,
#   height = 20,
#   units = "cm")
```









## Exclusive vs. Shared
Use same coding as above, but with different bins and palettes  


# D. Individual sourcing sheds

## Distribute cell attributes on coops
This uses normalised probabilities from the perspective of the *cell*. 
The idea is to export a coop-level data set with the weighted LU area in all sourcing sheds. 
Repeat for heuristic probabilities as well. 

```{r}

linked_coops = 
  links %>% 
  # add the LU vars produced ex post, on top of this script
  left_join(cells %>% select(CELL_ID, CELL_FOREST_HA, CELL_ALL_CD_HA, CELL_NODEF_EXPANSION_HA), 
            by = "CELL_ID") %>% 
  summarise(.by = "LINK_POTENTIAL_COOP_ID", 
            COOP_AREA_HA =            sum(cell_area_ha            * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_COCOA_HA =           sum(CELL_COCOA_HA           * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_FOREST_HA =          sum(CELL_FOREST_HA          * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_DENSEFOREST_HA =     sum(CELL_DENSEFOREST_HA     * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_OTHERFORESTS_HA =    sum(CELL_OTHERFORESTS_HA    * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_ALL_CD_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_OLD_CD_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_REC_CD_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            COOP_NODEF_EXPANSION_HA = sum(CELL_NODEF_EXPANSION_HA * CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED),
            
            COOP_CONDI_AREA_HA =            sum(cell_area_ha            * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_COCOA_HA =           sum(CELL_COCOA_HA           * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_FOREST_HA =          sum(CELL_FOREST_HA          * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_DENSEFOREST_HA =     sum(CELL_DENSEFOREST_HA     * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_OTHERFORESTS_HA =    sum(CELL_OTHERFORESTS_HA    * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_ALL_CD_HA =          sum(CELL_ALL_CD_HA          * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_OLD_CD_HA =          sum(CELL_OLD_CD_HA          * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_REC_CD_HA =          sum(CELL_REC_CD_HA          * LINK_PROBA_THRESH_NORMED),
            COOP_CONDI_NODEF_EXPANSION_HA = sum(CELL_NODEF_EXPANSION_HA * LINK_PROBA_THRESH_NORMED),
            
            COOP_AREA_H10KM_HA =            sum(cell_area_ha            * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_COCOA_H10KM_HA =           sum(CELL_COCOA_HA           * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_FOREST_H10KM_HA =          sum(CELL_FOREST_HA          * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_DENSEFOREST_H10KM_HA =     sum(CELL_DENSEFOREST_HA     * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_OTHERFORESTS_H10KM_HA =    sum(CELL_OTHERFORESTS_HA    * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_ALL_CD_H10KM_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_OLD_CD_H10KM_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_REC_CD_H10KM_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_NODEF_EXPANSION_H10KM_HA = sum(CELL_NODEF_EXPANSION_HA * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),

            COOP_AREA_H30KM_HA =            sum(cell_area_ha            * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_COCOA_H30KM_HA =           sum(CELL_COCOA_HA           * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_FOREST_H30KM_HA =          sum(CELL_FOREST_HA          * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_DENSEFOREST_H30KM_HA =     sum(CELL_DENSEFOREST_HA     * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_OTHERFORESTS_H30KM_HA =    sum(CELL_OTHERFORESTS_HA    * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_ALL_CD_H30KM_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_OLD_CD_H30KM_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_REC_CD_H30KM_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_NODEF_EXPANSION_H30KM_HA = sum(CELL_NODEF_EXPANSION_HA * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),

            COOP_AREA_H60KM_HA =            sum(cell_area_ha            * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_COCOA_H60KM_HA =           sum(CELL_COCOA_HA           * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_FOREST_H60KM_HA =          sum(CELL_FOREST_HA          * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_DENSEFOREST_H60KM_HA =     sum(CELL_DENSEFOREST_HA     * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_OTHERFORESTS_H60KM_HA =    sum(CELL_OTHERFORESTS_HA    * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_ALL_CD_H60KM_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_OLD_CD_H60KM_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_REC_CD_H60KM_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED), 
            COOP_NODEF_EXPANSION_H60KM_HA = sum(CELL_NODEF_EXPANSION_HA * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),

            COOP_AREA_HDISTR_HA =            sum(cell_area_ha            * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_COCOA_HDISTR_HA =           sum(CELL_COCOA_HA           * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_FOREST_HDISTR_HA =          sum(CELL_FOREST_HA          * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_DENSEFOREST_HDISTR_HA =     sum(CELL_DENSEFOREST_HA     * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_OTHERFORESTS_HDISTR_HA =    sum(CELL_OTHERFORESTS_HA    * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_ALL_CD_HDISTR_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_OLD_CD_HDISTR_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_REC_CD_HDISTR_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_NODEF_EXPANSION_HDISTR_HA = sum(CELL_NODEF_EXPANSION_HA * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED)

            )

cells = 
  cells %>% 
  mutate(CELL_COCOA_CSS_HA  = CELL_COCOA_HA *CELL_SHARE_COOP,
         CELL_FOREST_CSS_HA = CELL_FOREST_HA*CELL_SHARE_COOP, 
         CELL_ALL_CD_CSS_HA = CELL_ALL_CD_HA*CELL_SHARE_COOP, 
         CELL_NODEF_EXPANSION_CSS_HA = CELL_NODEF_EXPANSION_HA*CELL_SHARE_COOP)

(cocoa_aggr_pcss = cells$CELL_COCOA_CSS_HA %>% sum())
(all_cd_aggr_pcss = cells$CELL_ALL_CD_CSS_HA %>% sum())
(nodef_aggr_pcss = cells$CELL_NODEF_EXPANSION_CSS_HA %>% sum())
(forest_aggr_pcss = cells$CELL_FOREST_CSS_HA %>% sum())

linked_coops$COOP_FOREST_HA %>% sum()
linked_coops$COOP_FOREST_H10KM_HA %>% sum()
linked_coops$COOP_FOREST_HDISTR_HA %>% sum()

linked_coops$COOP_CONDI_FOREST_HA %>% sum()



```

## Hotspots

### Distribution
```{r}
linked_coops$COOP_ALL_CD_HA %>% summary()

linked_coops = 
  linked_coops %>% 
  mutate(
    COOP_PROP_OF_COCOA_HA = 100 * COOP_COCOA_HA / cocoa_aggr_pcss, 
    COOP_PROP_OF_FOREST_HA = 100 * COOP_FOREST_HA / forest_aggr_pcss, 

    COOP_PROP_OF_ALL_CD_HA = 100 * COOP_ALL_CD_HA / cocoa_aggr_pcss, 
    COOP_ALL_ANNUAL_CD_HA = COOP_ALL_CD_HA / 16
    )

linked_coops$COOP_PROP_OF_COCOA_HA %>% summary()
linked_coops$COOP_PROP_OF_FOREST_HA %>% summary()
linked_coops$COOP_PROP_OF_ALL_CD_HA %>% summary()

quantile(linked_coops$COOP_ALL_CD_HA, seq(0,1,0.1))
quantile(linked_coops$COOP_PROP_OF_ALL_CD_HA, seq(0,1,0.1))

# Calculate the cumulative sum of COOP_ALL_CD_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_ALL_CD_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_ALL_CD_HA_cumulative_sum = cumsum(COOP_ALL_CD_HA))

# Calculate the cumulative sum of COOP_ALL_CD_H10KM_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_ALL_CD_H10KM_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_ALL_CD_H10KM_HA_cumulative_sum = cumsum(COOP_ALL_CD_H10KM_HA))

# Calculate the cumulative sum of COOP_ALL_CD_HDISTR_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_ALL_CD_HDISTR_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_ALL_CD_HDISTR_HA_cumulative_sum = cumsum(COOP_ALL_CD_HDISTR_HA))

# Calculate the total sum 
total_sum <- sum(linked_coops$COOP_ALL_CD_HA)
total_sum_h10km <- sum(linked_coops$COOP_ALL_CD_H10KM_HA)
total_sum_hdistr <- sum(linked_coops$COOP_ALL_CD_HDISTR_HA)

# Calculate the cumulative percentage of COOP_ALL_CD_HA
linked_coops <- linked_coops %>%
  mutate(
    COOP_ALL_CD_RANK_cumulative_percentage        = 100*COOP_ALL_CD_HA_cumulative_sum / total_sum, 
    COOP_ALL_CD_RANK = case_when(
       COOP_ALL_CD_RANK_cumulative_percentage < 20 ~ "Bottom 20%",
       COOP_ALL_CD_RANK_cumulative_percentage >= 20 & COOP_ALL_CD_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_ALL_CD_RANK_cumulative_percentage >= 80 ~ "Top 20%"
       ),
    
    COOP_ALL_CD_H10KM_RANK_cumulative_percentage  = 100*COOP_ALL_CD_H10KM_HA_cumulative_sum / total_sum_h10km,
    COOP_ALL_CD_H10KM_RANK = case_when(
       COOP_ALL_CD_H10KM_RANK_cumulative_percentage < 20 ~ "Bottom 20%",
       COOP_ALL_CD_H10KM_RANK_cumulative_percentage >= 20 & COOP_ALL_CD_H10KM_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_ALL_CD_H10KM_RANK_cumulative_percentage >= 80 ~ "Top 20%"
       ),
    
    COOP_ALL_CD_HDISTR_RANK_cumulative_percentage = 100*COOP_ALL_CD_HDISTR_HA_cumulative_sum / total_sum_hdistr, 
    COOP_ALL_CD_HDISTR_RANK = case_when(
       COOP_ALL_CD_HDISTR_RANK_cumulative_percentage < 20 ~ "Bottom 20%",
       COOP_ALL_CD_HDISTR_RANK_cumulative_percentage >= 20 & COOP_ALL_CD_HDISTR_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_ALL_CD_HDISTR_RANK_cumulative_percentage >= 80 ~ "Top 20%"
       )
         )
linked_coops$COOP_ALL_CD_RANK %>% table()
linked_coops$COOP_ALL_CD_H10KM_RANK %>% table()
linked_coops$COOP_ALL_CD_HDISTR_RANK %>% table()

# Determine the number of observations in each decile
deciles <- seq(10, 100, by = 10)

# model
decile_counts <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_ALL_CD_RANK_cumulative_percentage <= d)
})
decile_results <- data.frame(
  Decile = deciles,
  Count = decile_counts
)

# 10km
decile_counts_h10km <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_ALL_CD_H10KM_RANK_cumulative_percentage <= d)
})
decile_results_h10km <- data.frame(
  Decile = deciles,
  Count = decile_counts_h10km
)
# district
decile_counts_hdistr <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_ALL_CD_HDISTR_RANK_cumulative_percentage <= d)
})
decile_results_hdistr <- data.frame(
  Decile = deciles,
  Count = decile_counts_hdistr
)

decile_results
decile_results_h10km
decile_results_hdistr
# Create the ECDF plot
# ggplot(linked_coops, aes(x = COOP_ALL_CD_HA)) +
#   stat_ecdf(geom = "step", color = "blue") +
#   labs(title = "ECDF Plot of cocoa deforestation in individual PCSS",
#        x = "cocoa deforestation",
#        y = "Cumulative Probability") +
#   theme_minimal()

# Create the violin plot
# ggplot(linked_coops, aes(x = factor(1), y = COOP_ALL_CD_HA)) +
#   geom_violin(fill = "blue", alpha = 0.6) +
#   labs(title = "Violin Plot of of cocoa deforestation in individual PCSS",
#        x = "cocoa deforestation",
#        y = "Density") +
#   theme_minimal()

# bubbles(value = linked_coops$COOP_PROP_OF_ALL_CD_HA, 
#         label = as.character(round(linked_coops$COOP_ALL_ANNUAL_CD_HA, 0)))

coop22_sf = 
  coopbs22_sf %>% 
  # keep only one BS point for plotting this
  distinct(COOP_ID, .keep_all = TRUE) %>% 
  left_join(linked_coops, 
            by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID)) %>% 
  arrange(desc(COOP_ALL_CD_HA))

# 20% of the cocoa deforestation attributable to cooperatives is in the supply sheds of less than 1% of cooperatives.
100*decile_results[2,"Count"]/nrow(coop22_sf)

map_hotspot_coops_all_cd = 
 ggplot(coop22_sf) +
  geom_sf(mapping = aes(size = COOP_ALL_CD_RANK, fill = COOP_ALL_CD_HA),
         shape = 21) + #, col = COOP_ALL_CD_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Top 20%" = 0.1,"20-80%" = 1,"Bottom 20%" = 4)
                    ) +
  # scale_colour_viridis_c(na.value = "transparent", name = "Absolute",
  #                        labels=unit_format(unit = "ha", sep = "")) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Hotspot cocoa deforestation in individual PCSS",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

ggsave(
  plot = map_hotspot_coops_all_cd,
  filename = paste0("map_hotspot_coops_all_cd.png"),
  path = here("outputs", "individual_sheds"),
  width = 25,
  height = 20,
  units = "cm")



map_hotspot_coops_all_cd_distr = 
 ggplot(coop22_sf) +
  geom_sf(mapping = aes(size = COOP_ALL_CD_HDISTR_RANK, fill = COOP_ALL_CD_HDISTR_HA),
         shape = 21) + #, col = COOP_ALL_CD_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Top 20%" = 0.1,"20-80%" = 1,"Bottom 20%" = 4)
                    ) +
  # scale_colour_viridis_c(na.value = "transparent", name = "Absolute",
  #                        labels=unit_format(unit = "ha", sep = "")) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Hotspot cocoa deforestation in department supply sheds",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

ggsave(
  plot = map_hotspot_coops_all_cd_distr,
  filename = paste0("map_hotspot_coops_all_cd_distr.png"),
  path = here("outputs", "individual_sheds"),
  width = 25,
  height = 20,
  units = "cm")

```





### Maps
In addition, for display purposes, add approximate supply shed polygons

We define for every cell to which coop it most likely supplies (conditional on supplying any coop in the first place). 
I.e. we identify the most likely links for every cell. 
This is not completely sharp polygons though (i.e. there are still overlaps), as we still have many equi-probabilities... 

Then, unionize the cell by coop id and merge with linked_coop

```{r}
# Find the max conditional, normalised proba in every cell. 
# Using the unconditional probas would yield exactly the same result, as it just differs by a cell-level quantity, 
# EXCEPT in cells that don't pass the 1st stage threshold. There, unconditional probas would all be null, but conditional probas aren't. So using *conditional* probas allows to also determine which coop is most likely supplied in cells not selling to coops at all. 

links = 
  links %>% 
  group_by(CELL_ID) %>% 
  mutate(
    LINK_PROBA_THRESH_NORMED_CELLMAX = max(LINK_PROBA_THRESH_NORMED), 
  ) %>% 
  ungroup() %>% 
  mutate(LINK_IS_MOST_LIKELY = case_when(
    LINK_PROBA_THRESH_NORMED_CELLMAX == 0 | # where all probas are null
      # or where their maximum is strictly higher than the link's proba, the link is NOT most likely
    LINK_PROBA_THRESH_NORMED_CELLMAX > LINK_PROBA_THRESH_NORMED ~ FALSE, 
    is.na(LINK_PROBA_THRESH_NORMED_CELLMAX) ~ NA,
    TRUE ~ TRUE
    )
  ) %>% 
  group_by(CELL_ID) %>% 
  mutate(CELL_N_MOST_LIKELY_LINKS = sum(LINK_IS_MOST_LIKELY, na.rm = T)) %>% 
  ungroup() 

# Equi-probabilities are allowed. 
# We have them for a few truly predicted probas. 
links %>%   
  filter(CELL_N_MOST_LIKELY_LINKS > 1) %>% 
  arrange(CELL_ID) %>% 
  View()

# Before, we had them for many of the observed links, which predicted probability to exist is 1, and thus normalised probability is 1/n with n is the number of observed links in cell.
# But now these links are merged into one single cell-coop link in the predict set links.  
links %>%   
  filter(CELL_N_MOST_LIKELY_LINKS > 1) %>% 
  filter(!is.na(PRO_ID)) %>% 
  nrow()

links %>%   
  filter(CELL_N_MOST_LIKELY_LINKS == 1) %>% nrow()

links$LINK_IS_MOST_LIKELY %>% summary()
# 2280 cells have a most likely link. This means that in all the other cells, the probabilities to sell to the different coops are all null. 
links %>% filter(LINK_IS_MOST_LIKELY) %>% pull(CELL_ID) %>% unique() %>% length()

# This connects to 275 cooperatives only! 
# It means that a few coops are always the most likely to have a link. 
# IT DOES NOT MEAN THAT THESE ARE THE ONLY COOPS PREDICTED TO HAVE A LINK! 
links %>% filter(LINK_IS_MOST_LIKELY) %>% pull(LINK_POTENTIAL_COOP_ID) %>% unique() %>% length()

# and it's not because we don't have enough information on the 4100 more coops!  
links$LINK_POTENTIAL_COOP_ID %>% unique() %>% length()
links %>% select(all_of(stg2_allfeatures)) %>%  anyNA()
```




Make polygons
```{r}
cell_coop_sheds = 
  links %>% 
  filter(LINK_IS_MOST_LIKELY) %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  st_buffer(dist = 1e3*MODEL_RESOLUTION_KM/2)
stmp = cell_coop_sheds[1,]

# make them square
st_geometry(cell_coop_sheds) <- 
  sapply(st_geometry(cell_coop_sheds), FUN = function(x){st_as_sfc(st_bbox(x))}) %>% st_sfc(crs = civ_crs)

# ggplot() + 
#   geom_sf(data = cell_coop_sheds[1,], fill = "black", col = "black", size = 2) + 
#   geom_sf(data = stmp, col = "red", fill = "red", size = 2)

# Merge cells by coop id to make supply shed of coop 
cell_coop_sheds = 
  cell_coop_sheds %>% 
  summarise(.by = LINK_POTENTIAL_COOP_ID, 
            geometry = st_union(geometry)
            ) %>% 
  rename(COOP_ID = LINK_POTENTIAL_COOP_ID) #%>% 
  # left_join(linked_coops, 
  #           by = "LINK_POTENTIAL_COOP_ID")

ggplot() + 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = cell_coop_sheds, aes(fill = COOP_ID), size = 2) + 
  guides(fill="none")


# Make polygons based on heuristics
coopbs_in_model = 
  coopbs22 %>% 
  filter(COOP_ID %in% cell_coop_sheds$COOP_ID) %>% 
  filter(!is.na(LONGITUDE)) %>% # this removes some buying stations that don't have coordinates, but no coop fully. 
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  select(COOP_ID, geometry) # %>% 
  # left_join(cell_coop_sheds %>% st_drop_geometry(), 
  #           by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID))

coop_sheds_h10km = 
     coopbs_in_model %>% 
     st_buffer(dist = 10*1e3)
 
coop_sheds_h30km = 
   coopbs_in_model %>% 
   st_buffer(dist = 30*1e3)

coop_sheds_h60km = 
   coopbs_in_model %>% 
   st_buffer(dist = 60*1e3)
 
# names(cell_coop_sheds) = tolower(names(cell_coop_sheds))
# names(cell_coop_sheds) = tolower(names(cell_coop_sheds))
# dir.create(here("temp_data", "individual_coop_supply_sheds", "cell_coop_sheds"), recursive = TRUE) 
# st_write(cell_coop_sheds, here("temp_data", "individual_coop_supply_sheds",
#                                 "cell_coop_sheds",
#                                 "cell_coop_sheds.shp"))
# 
# dir.create(here("temp_data", "individual_coop_supply_sheds", "coop_sheds_h10km"), recursive = TRUE) 
# st_write(coop_sheds_h10km, here("temp_data", "individual_coop_supply_sheds",
#                                 "coop_sheds_h10km", 
#                                 "coop_sheds_h10km.shp"), 
#          append = FALSE)
# 
# dir.create(here("temp_data", "individual_coop_supply_sheds", "coop_sheds_h30km"), recursive = TRUE) 
# write_sf(coop_sheds_h30km, here("temp_data", "individual_coop_supply_sheds",
#                                 "coop_sheds_h30km", 
#                                 "coop_sheds_h30km.shp"))
# 
# dir.create(here("temp_data", "individual_coop_supply_sheds", "coop_sheds_h60km"), recursive = TRUE) 
# write_sf(coop_sheds_h60km, here("temp_data", "individual_coop_supply_sheds",
#                                 "coop_sheds_h60km", 
#                                 "coop_sheds_h60km.shp"))

```

## Hotspots


## Heuristics

# Additional stuff 
## Distance map

```{r}
cells_toplot = 
  cells_toplot %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs) 

cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS %>% summary()
# Max share of coop outlet, rounded up for clean display
max_dist = round(max(cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS, na.rm = TRUE)+5,-1)

# Depending on final results, choose to show in 3 or 4 bins
bin_names = c("0-15km", "15-45km", paste0("45-",max_dist,"km"))

# Custom breaks bc we want the lowest bin to be 0 only. 
cells_toplot$`Avg. distance 5 nearest coops (m)` = 
  cut(cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      include.lowest = TRUE,
      breaks = c(0,15000,45000,max_dist), 
      labels = bin_names
      )

cells_toplot$`Avg. distance 5 nearest coops (m)` %>% table()

# Make palette with same colors as in the bivariate map
uni_in_bi_pal_outlet = 
  bi_pal("PurpleOr", dim = 3, preview = F)
uni_in_bi_pal_outlet = uni_in_bi_pal_outlet[grepl("1-", names(uni_in_bi_pal_outlet))]
names(uni_in_bi_pal_outlet) = bin_names
uni_in_bi_pal_outlet

map =
  ggplot(cells_toplot) +
  geom_sf(mapping = aes(fill = `Avg. distance 5 nearest coops (m)`, col = `Avg. distance 5 nearest coops (m)`),
          size = 1, shape = 22) + #
  scale_fill_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  scale_colour_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  
   # geom_sf(mapping = aes(fill = CELL_SHARE_COOP, col = CELL_SHARE_COOP), 
   #        size = 1, shape = 22) + # 
  
  geom_sf(data = coopbs22_sf, col = "black", size = 0.7) +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Distance to cooperatives",
    subtitle = ""
  ) 

map

```


# Old Stuff
### Discrete map 
```{r}
# Make cell categories
# keep in mind that the purpose of this is a map, not an analysis! 

# Start from link level
links = 
  links %>% 
  mutate(
    CELL_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0, 
     # This is where no cocoa is estimated to be sold to coops, but independent of that, some links with coops are predicted to exist (they pass the threshold). 
    CELL_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0, 
    
    # Productive sourcing sheds: actual, influential and outside 
    CELL_PRODUCTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE",
    CELL_PRODUCTIVE_OUTSIDE = CELL_SHARE_COOP == 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    
    # Prospective sourcing sheds: actual, influential and outside 
    CELL_PROSPECTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_OUTSIDE = CELL_SHARE_COOP == 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 

    
    `Sourcing shed type` = case_when(
      CELL_PRODUCTIVE_SOURCING_SHED_ONLY ~ "Productive, actual",
      CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY ~ "Productive, influential", 
      CELL_PRODUCTIVE_OUTSIDE ~ "Productive, outside",
      CELL_PROSPECTIVE_SOURCING_SHED_ONLY ~ "Prospective, actual",
      CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY ~ "Prospective, influential", 
      CELL_PROSPECTIVE_OUTSIDE ~ "Prospective, outside",

      TRUE ~ NA
    )
    )

# links %>% 
#   filter(is.na(`Sourcing shed type`)) %>% 
#   select(CELL_PRODUCTIVE_SOURCING_SHED_ONLY, CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY, CELL_PROSPECTIVE_SOURCING_SHED_ONLY, CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY) %>% 
#   summary()

cells = 
  cells %>% 
  left_join(
    links %>% select(CELL_ID, `Sourcing shed type`) %>% distinct(CELL_ID, .keep_all = TRUE), 
    by = "CELL_ID", multiple = "all"
  )
cells$`Sourcing shed type` %>% table()

# Check that we cover all cells we predicted a coop outlet share (i.e. excluding not in AoA)
stopifnot(
cells %>% filter(!is.na(CELL_SHARE_COOP)) %>% nrow() == sum(table(cells$`Sourcing shed type`))
)
```

A discrete map may be misleading though, as it may represent many cells in the actual sourcing shed, while their predicted shares of coop outlet are small and uncertain. 


