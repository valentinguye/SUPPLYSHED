---
title: "Outputs"
author: "Valentin"
date: "`r Sys.Date()`"
output: 
  html_document:
      self_contained: false
---

# Set up and inputs
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(aws.s3)
aws.signature::use_credentials()
Sys.setenv("AWS_DEFAULT_REGION" = "eu-west-1")


library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)
library(here)
library(tictoc)
library(readstata13)
library(sjmisc)
library(terra) # put it after {raster} such that it superceeds homonym functions. 
library(exactextractr)
library(stars)
library(pals)
library(modelsummary) # necessary to load it after DescTools

library(biscale)
library(cowplot)
library(viridis)

set.seed(8888)

# install.packages("https://cran.r-project.org/src/contrib/Archive/isotree/isotree_0.5.5.tar.gz",
#                  repos = NULL, 
#                  type = "source")

# Storage directories
dir.create(here("outputs", "aggregate_sheds"), recursive = TRUE)


## Functions
# Trase palettes etc. for plots
source(here("code", "theme_trase.R"))

# load in particular the function fn_trader_to_group_names, str_trans, ... 
source(here("code", "USEFUL_STUFF_supplyshedproj.R"))

# use the projected CRS used by BNETD for their 2020 land use map. 
civ_crs <- 32630

MODEL_RESOLUTION_KM = 4
cell_area_ha =(100*MODEL_RESOLUTION_KM^2)

xlabs = c(-8, -6, -4)
ylabs = c(5, 7, 9)

## Assets

departements <- read_sf(here("input_data/s3/CIV_DEPARTEMENTS.geojson"))
departements = 
  st_transform(departements, crs = civ_crs)

coopbsy = read.csv(file = here("temp_data/private_IC2B/IC2B_v2_coop_bs_year.csv"))
coopbs22 = coopbsy %>% filter(YEAR == 2022)

links = readRDS(here("temp_data", "model", paste0("links.Rdata")))

cells = readRDS(here("temp_data", "model", paste0("cells.Rdata"))) 

# Useful variables 
cells = 
  cells %>% 
  mutate(
    CELL_NODEF_EXPANSION_HA = 
           1600
         - CELL_COCOA_HA
         - CELL_DENSEFOREST_HA
         - CELL_OTHERFORESTS_HA
         - CELL_IMPOSSIBLE_HA, 
    CELL_ALL_CD_HA = CELL_OLD_CD_HA + CELL_REC_CD_HA,
    CELL_1minusSHARE_COOP_SIGNI = 1 - CELL_SHARE_COOP_SIGNI) 

```

## Transformations for display
```{r}
cells_toplot = 
  cells %>% 
  mutate(
   # Work on PERCENTAGE, not share, from here, for display. 
    CELL_SHARE_COOP_SIGNI = 100*CELL_SHARE_COOP_SIGNI,
    CELL_COCOA_SHARE = 100*CELL_COCOA_SHARE, 
    # Round hectares
    across(.cols = ends_with("_HA"), .fns = ~round(.x, 0))
    )

```


# Aggregate sourcing sheds 
This uses mostly first stage results. 

## Outside vs. Within

### Aggregate numbers

```{r}
# The area of each LU category WITHIN the aggregate sourcing shed: 
fn_aggregate_lu = function(out_or_in_share){
  cells %>%
  summarise(.by = CELL_IS_IN_AOA, 
            `N CELLS` = sum({{out_or_in_share}}>0), # this will probably be removed eventually
            TOTAL          = round(sum({{out_or_in_share}}*1600) / 1000, 1),
            COCOA          = round(sum({{out_or_in_share}}*CELL_COCOA_HA) / 1000, 1),
            FOREST         = round(sum({{out_or_in_share}}*(CELL_DENSEFOREST_HA+CELL_OTHERFORESTS_HA)) / 1000, 1),
            `DENSE FOREST` = round(sum({{out_or_in_share}}*CELL_DENSEFOREST_HA) / 1000, 1),
            `OTHER FOREST` = round(sum({{out_or_in_share}}*CELL_OTHERFORESTS_HA) / 1000, 1),
            `AVAILABLE, NOT FORESTED LAND` = round(sum({{out_or_in_share}}*CELL_NODEF_EXPANSION_HA) / 1000, 1)
            ) %>% 
  filter(CELL_IS_IN_AOA) %>% 
  select(-CELL_IS_IN_AOA)
}
aggr_tbl = 
  rbind(
    fn_aggregate_lu(CELL_SHARE_COOP_SIGNI) %>% 
      mutate(` ` = "Within", .before = everything()),
    fn_aggregate_lu(CELL_1minusSHARE_COOP_SIGNI) %>% 
      mutate(` ` = "Outside", .before = everything())
  )
  
aggr_tbl

out_tbl = 
  aggr_tbl %>% 
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
  # row_spec(12, extra_css = "padding-left: 20px;")

out_tbl

save_kable(out_tbl, here("outputs", "aggregate_sheds", "LU_in_out.png"))

```


### Univariate map 
Decide to have 3 or 4 bins in the end, based on final data. 
```{r}
cells_toplot$CELL_COCOA_SHARE %>% summary()
cells_toplot$CELL_COCOA_HA %>% summary()
cells_toplot$CELL_SHARE_COOP_SIGNI %>% summary()
cells_toplot$CELL_SHARE_COOP_SIGNI %>% quantile(seq(0, 1, 0.1), na.rm = T)

cells_toplot = 
  cells_toplot %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs) 

aoa_cells_toplot = 
  cells_toplot %>% 
  filter(CELL_IS_IN_AOA)

oaoa_cells_toplot = 
  cells_toplot %>% 
  filter(!CELL_IS_IN_AOA)

# Max share of coop outlet, rounded up for clean display
max_share_coop = round(max(aoa_cells_toplot$CELL_SHARE_COOP_SIGNI, na.rm = TRUE)+5,-1)

# Depending on final results, choose to show in 3 or 4 bins
bin_names = c("0%", "0-30%", paste0("30-",max_share_coop,"%"))

# Custom breaks bc we want the lowest bin to be 0 only. 
aoa_cells_toplot$`Cooperative outlet (%)` = 
  cut(aoa_cells_toplot$CELL_SHARE_COOP_SIGNI, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      include.lowest = TRUE,
      breaks = c(0,1e-9,30,max_share_coop), 
      labels = bin_names
      )

aoa_cells_toplot$`Cooperative outlet (%)` %>% table()

# Make palette with same colors as in the bivariate map
uni_in_bi_pal_outlet = 
  bi_pal("GrPink2", dim = 3, preview = F)
uni_in_bi_pal_outlet = uni_in_bi_pal_outlet[grepl("1-", names(uni_in_bi_pal_outlet))]
names(uni_in_bi_pal_outlet) = bin_names
uni_in_bi_pal_outlet

map =
  ggplot(aoa_cells_toplot) +
  geom_sf(mapping = aes(fill = `Cooperative outlet (%)`, col = `Cooperative outlet (%)`), 
          size = 1, shape = 22) + # 
  scale_fill_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  scale_colour_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Cooperative outlet",
    subtitle = ""
  ) 

map
ggsave(
  plot = map,
  filename = paste0("cooperative_outlet.png"),
  path = here("outputs", "aggregate_sheds"), 
  width = 25, 
  height = 20,
  units = "cm")
```



### Bivariate maps
Use biscale package. Different vignettes, including on available bivariate palettes here: 
https://cran.r-project.org/web/packages/biscale/index.html

```{r}
aoa_cells_toplot$CELL_COCOA_HA %>% summary()

# This makes the bivariate bins
aoa_cells_toplot = 
  aoa_cells_toplot %>% 
  bi_class(CELL_COCOA_HA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  aoa_cells_toplot %>% 
  bi_class_breaks(CELL_COCOA_HA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4) 
breaks$bi_y = bin_names

map =
  ggplot() +
  geom_sf(data = aoa_cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  bi_scale_fill(pal = "GrPink2", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "GrPink2", dim = 3, na.value = "transparent") +
  labs(
    title = "Cooperative outlet and cocoa extent",
    subtitle = ""
  ) +
  bi_theme()

legend <- bi_legend(pal = "GrPink2",
                    dim = 3,
                    xlab = "Extent of cocoa farms (ha)",
                    ylab = "Cooperative outlet (%)",
                    size = 6, 
                    breaks = breaks)



continous_aggregate_plot = 
  ggdraw() +
  draw_plot(map, 0, 0, 1, 1) +
  draw_plot(legend, x = 0.7, y = 0.2, width = 0.3, height = 0.3)

continous_aggregate_plot
```


Continuous productive
```{r}
# # This is mainly for plotting purposes - not even actually, it's useless. 
# table(cells$CELL_PRODUCTION_STATUS)
# 
# links = 
#   links %>% 
#   mutate(
#     # Commented out since I don't know what this should be used for - to weights ! (not summing to 1)
#     # across(.cols = contains("_PROBA_"), 
#     #        .fns = ~ .x  * CELL_COCOA_SHARE, 
#     #        .names = paste0("{.col}", "_COCOA")), 
#     CELL_SHARE_COOP_SIGNI_COCOA = CELL_SHARE_COOP_SIGNI * CELL_COCOA_SHARE
#   )
# 
# links %>% select(ends_with("_COCOA")) %>% names()

```


### Discrete map 
```{r}
# Make cell categories
# keep in mind that the purpose of this is a map, not an analysis! 

# Start from link level
links = 
  links %>% 
  mutate(
    CELL_SOURCING_SHED_ONLY = CELL_SHARE_COOP_SIGNI > 0, 
     # This is where no cocoa is estimated to be sold to coops, but independent of that, some links with coops are predicted to exist (they pass the threshold). 
    CELL_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP_SIGNI == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0, 
    
    # Productive sourcing sheds: actual, influential and outside 
    CELL_PRODUCTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP_SIGNI > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP_SIGNI == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE",
    CELL_PRODUCTIVE_OUTSIDE = CELL_SHARE_COOP_SIGNI == 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    
    # Prospective sourcing sheds: actual, influential and outside 
    CELL_PROSPECTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP_SIGNI > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP_SIGNI == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_OUTSIDE = CELL_SHARE_COOP_SIGNI == 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 

    
    `Sourcing shed type` = case_when(
      CELL_PRODUCTIVE_SOURCING_SHED_ONLY ~ "Productive, actual",
      CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY ~ "Productive, influential", 
      CELL_PRODUCTIVE_OUTSIDE ~ "Productive, outside",
      CELL_PROSPECTIVE_SOURCING_SHED_ONLY ~ "Prospective, actual",
      CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY ~ "Prospective, influential", 
      CELL_PROSPECTIVE_OUTSIDE ~ "Prospective, outside",

      TRUE ~ NA
    )
    )

# links %>% 
#   filter(is.na(`Sourcing shed type`)) %>% 
#   select(CELL_PRODUCTIVE_SOURCING_SHED_ONLY, CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY, CELL_PROSPECTIVE_SOURCING_SHED_ONLY, CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY) %>% 
#   summary()

cells = 
  cells %>% 
  left_join(
    links %>% select(CELL_ID, `Sourcing shed type`) %>% distinct(CELL_ID, .keep_all = TRUE), 
    by = "CELL_ID", multiple = "all"
  )
cells$`Sourcing shed type` %>% table()

# Check that we cover all cells we predicted a coop outlet share (i.e. excluding not in AoA)
stopifnot(
cells %>% filter(!is.na(CELL_SHARE_COOP)) %>% nrow() == sum(table(cells$`Sourcing shed type`))
)
```

A discrete map may be misleading though, as it may represent many cells in the actual sourcing shed, while their predicted shares of coop outlet are small and uncertain. 



## Exclusive vs. Shared
Use same coding as above, but with different bins and palettes  


# Individual sourcing sheds

## Hotspots


## Heuristics
