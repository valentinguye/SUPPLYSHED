---
title: "Outputs"
author: "Valentin"
date: "`r Sys.Date()`"
output: 
  html_document:
      self_contained: false
---

# Set up and inputs
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(aws.s3)
aws.signature::use_credentials()
Sys.setenv("AWS_DEFAULT_REGION" = "eu-west-1")


library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)
library(here)
library(tictoc)
library(readstata13)
library(sjmisc)
library(terra) # put it after {raster} such that it superceeds homonym functions. 
library(exactextractr)
library(stars)
library(pals)
library(modelsummary) # necessary to load it after DescTools

library(biscale)
library(cowplot)
library(viridis)


set.seed(8888)

# install.packages("https://cran.r-project.org/src/contrib/Archive/isotree/isotree_0.5.5.tar.gz",
#                  repos = NULL, 
#                  type = "source")

# Storage directories
dir.create(here("outputs", "aggregate_sheds"), recursive = TRUE)
dir.create(here("temp_data", "food_security_VSS"), recursive = TRUE)

## Functions
# Trase palettes etc. for plots
source(here("code", "theme_trase.R"))

# load in particular the function fn_trader_to_group_names, str_trans, ... 
source(here("code", "USEFUL_STUFF_supplyshedproj.R"))

# use the projected CRS used by BNETD for their 2020 land use map. 
civ_crs <- 32630

MODEL_RESOLUTION_KM = 4
cell_area_ha =(100*MODEL_RESOLUTION_KM^2)

xlabs = c(-8, -6, -4)
ylabs = c(5, 7, 9)

## Assets

departements <- read_sf(here("input_data/s3/CIV_DEPARTEMENTS.geojson"))
departements = 
  st_transform(departements, crs = civ_crs) %>% 
  mutate(AREA_HA = st_area(geometry)/10000)

departements$AREA_HA %>% summary()

coopbsy = read.csv(file = here("temp_data/private_IC2B/IC2B_v2_coop_bs_year.csv"))

coopbs22 = coopbsy %>% filter(YEAR == 2022) %>% 
  # do that to match the output of the model 
  mutate(COOP_ID = paste0("COOP-",COOP_ID)) 

coopbs22_sf = 
  coopbs22 %>% 
  filter(!is.na(LONGITUDE)) %>% 
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326)

coopbs22_sf$COOP_ID %>% unique() %>% length() 

# Object with only one BS point (for plotting)
coop22_sf = 
  coopbs22_sf %>% 
  distinct(COOP_ID, .keep_all = TRUE) 

links = readRDS(here("temp_data", "model", paste0("links_topredict.Rdata")))

cells = readRDS(here("temp_data", "model", paste0("cells_topredict.Rdata"))) 

# Useful variables 
cells = 
  cells %>% 
  mutate(
    CELL_NDDEP_HA = 
           cell_area_ha
         - CELL_COCOA_HA
         - CELL_DENSEFOREST_HA
         - CELL_OTHERFORESTS_HA
         - CELL_IMPOSSIBLE_HA, 
    CELL_FOREST_HA = CELL_DENSEFOREST_HA + CELL_OTHERFORESTS_HA,
    CELL_ALL_CD_HA = CELL_OLD_CD_HA + CELL_REC_CD_HA,
    CELL_1minusSHARE_COOP = 1 - CELL_SHARE_COOP, 
    
    CELL_NDDEP_SHARE = CELL_NDDEP_HA / cell_area_ha,
    CELL_FOREST_SHARE = CELL_FOREST_HA / cell_area_ha,
    CELL_DENSEFOREST_SHARE = CELL_DENSEFOREST_HA / cell_area_ha,
    CELL_OTHERFORESTS_SHARE = CELL_OTHERFORESTS_HA / cell_area_ha
   ) 

links = 
  links %>% 
  left_join(
    cells %>% select(CELL_SHARE_COOP, CELL_ID), 
    by = "CELL_ID"
  ) %>% 
  # add the LU vars produced above
  left_join(cells %>% select(CELL_ID, CELL_FOREST_HA, CELL_ALL_CD_HA, CELL_NDDEP_HA), 
            by = "CELL_ID") %>% 
  group_by(CELL_ID) %>% 
  mutate(CELL_N_POTENTIAL_LINKS = length(na.omit(unique(LINK_POTENTIAL_COOP_ID)))) %>% 
  ungroup()

```


# POST-PROCESSING 
This is all at the Links level. 

Helper functions

## Heuristic probabilities
```{r}
all_heuristics_dist_km = seq(3,72,3)

for(heuristic_dist_km in all_heuristics_dist_km){
  links = 
    links %>% 
  # Determine, for every link, whether it exists under a given heuristic distance or not. 
    mutate(
      !!as.symbol(paste0("LINK_PROBA_H",heuristic_dist_km,"KM")) := if_else(LINK_DISTANCE_METERS <= heuristic_dist_km*1e3, 1, 0))
}
# Additional heuristics
links = 
  links %>% 
  mutate(
      LINK_PROBA_HDISTR = if_else(CELL_DISTRICT_NAME == COOP_DISTRICT_NAME, 1, 0), 
      LINK_PROBA_HCONTI = 1/LINK_DISTANCE_METERS
  )
```

## Normalized probabilities - cell perspective
This is necessary to distribute cell attributes onto cooperatives. 
It is not necessary to work on unconditional probabilities. It is strictly equivalent to uncondition before or after normalising, since unconditioning is multiplying by a cell-level quantity. 
Normalise heuristic probabilities as well. 
```{r}
# links_data = links
# link_proba_to_normalize = "LINK_PROBA_THRESH"
fn_normalize_link_proba = function(links_data, link_proba_to_normalize){
  links_data = 
    links_data %>% 
    group_by(CELL_ID) %>% 
    mutate(
      NORMALISING_SUM := sum(!!as.symbol(link_proba_to_normalize))
    ) %>% 
    ungroup() 
   
# When denominator is null, i.e. all links in cell have probas = 0, then make the normalised probas ALL AS LIKELY (i.e. 1/number of potential links) because the point here is not to reflect unconditional probabilities to sell to a coop, but *conditional* probabilities, i.e. the probability to sell to coops even very far, very unlikely, if we knew for sure that cocoa is sold to some coops. In other words, if we knew cocoa is sold to coops and not other buyers, what coops would it be?  

# Ok but the thing is that we will never know for sure, even with first stage model. Precisely, the first stage model is not super performant, so we might want to leverage information from the links data to learn about these places that sell to no coop. 
  
# However, for heuristics, set it to zero, because this is the rule of heuristics. 
  if(link_proba_to_normalize == "LINK_PROBA_THRESH"){
     links_data = 
       links_data %>% 
       mutate(
        LINK_PROBA_THRESH_NORMED = case_when(
          NORMALISING_SUM > 0 ~ LINK_PROBA_THRESH / NORMALISING_SUM, 
          TRUE ~ 1 / CELL_N_POTENTIAL_LINKS
          ))
  }
  if(link_proba_to_normalize == "LINK_PROBA_HCONTI"){
  links_data = 
     links_data %>% 
     mutate(
      # no need for a case_when here, because CELL_NORMSUM_HCONTI == 0 never happens 
      LINK_PROBA_HCONTI_NORMED = LINK_PROBA_HCONTI / NORMALISING_SUM
     )
  }    
  if(grepl("KM", link_proba_to_normalize) | link_proba_to_normalize == "LINK_PROBA_HDISTR"){
  links_data = 
     links_data %>% 
     mutate(
      !!as.symbol(paste0(link_proba_to_normalize,"_NORMED")) := case_when(
        NORMALISING_SUM > 0 ~ !!as.symbol(link_proba_to_normalize) / NORMALISING_SUM, 
        TRUE ~ 0
        ))
  }
  
  stopifnot(
  links_data %>% filter(is.na(!!as.symbol(paste0(link_proba_to_normalize,"_NORMED")))) %>% nrow() == 0 
  )
  
  stopifnot(
    links_data %>% select(all_of(paste0(link_proba_to_normalize,"_NORMED"))) %>% sum(na.rm = T) %>% round(5)  == length(unique(links_data$CELL_ID)) 
    # + length(unique(pull(filter(links_data, NORMALISING_SUM == 0), CELL_ID))) # that was for when we (wrongly) set conditional probas to 0 where normsum = 0
  )
 # links_data %>% summarise(.by=CELL_ID, TEST := sum(!!as.symbol(paste0(link_proba_to_normalize,"_NORMED")))) %>% pull(TEST) %>% unique()
 
  return(links_data) 
} 

links = fn_normalize_link_proba(links_data = links, "LINK_PROBA_THRESH")

```

## Unconditional probabilities

```{r}
# Helper function: Calculate the total area and specific LU areas embedded in individual links, for a given normalised link probability variable (which can be the modeled one, or heuristic ones). 

fn_links_lus = function(links_data, link_proba_normed_var){
    links_data %>% 
    mutate(
      LINK_PROBA_THRESH_UNCOND := CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var),
      LINK_AREA_HA =            cell_area_ha         * LINK_PROBA_THRESH_UNCOND,
      LINK_COCOA_HA =           CELL_COCOA_HA        * LINK_PROBA_THRESH_UNCOND,
      LINK_FOREST_HA =          CELL_FOREST_HA       * LINK_PROBA_THRESH_UNCOND,
      LINK_DENSEFOREST_HA =     CELL_DENSEFOREST_HA  * LINK_PROBA_THRESH_UNCOND,
      LINK_OTHERFORESTS_HA =    CELL_OTHERFORESTS_HA * LINK_PROBA_THRESH_UNCOND,
      LINK_ALL_CD_HA =          CELL_ALL_CD_HA       * LINK_PROBA_THRESH_UNCOND,
      LINK_OLD_CD_HA =          CELL_OLD_CD_HA       * LINK_PROBA_THRESH_UNCOND,
      LINK_REC_CD_HA =          CELL_REC_CD_HA       * LINK_PROBA_THRESH_UNCOND,
      LINK_NDDEP_HA =           CELL_NDDEP_HA        * LINK_PROBA_THRESH_UNCOND
    ) 
}

links = fn_links_lus(links, "LINK_PROBA_THRESH")
```


## ICCSS LUs
Prepare ICCSS is equivalent to MAKING COOP EXPOSURES TO CELL ATTRIBUTES 
This uses normalised probabilities from the perspective of the *cell*. 
The idea is to get a coop-level data frame with the weighted LU area in all sourcing sheds. 
Repeat for heuristic probabilities as well. 

```{r}
# Helper function: Calculate the total area and specific LU areas in the ICCSS of each coop, for a given normalised link probability variable (which can be the modeled one, or heuristic ones). 

fn_iccss_lus = function(links_data, link_proba_normed_var){
  linked_coops = 
    links_data %>% 
    # remove cells outside AOA).   
    filter(!(is.na(CELL_SHARE_COOP))) %>% 
    # remove coops without any potential link predicted with a positive proba. 
    group_by(LINK_POTENTIAL_COOP_ID) %>%
    filter(any(LINK_PROBA_THRESH > 0)) %>%
    ungroup() %>%
    summarise(.by = "LINK_POTENTIAL_COOP_ID", 
              COOP_AREA_HA =            sum(cell_area_ha            * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_COCOA_HA =           sum(CELL_COCOA_HA           * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_FOREST_HA =          sum(CELL_FOREST_HA          * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_DENSEFOREST_HA =     sum(CELL_DENSEFOREST_HA     * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_OTHERFORESTS_HA =    sum(CELL_OTHERFORESTS_HA    * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_ALL_CD_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_OLD_CD_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_REC_CD_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var)),
              COOP_NDDEP_HA = sum(CELL_NDDEP_HA * CELL_SHARE_COOP * !!as.symbol(link_proba_normed_var))
    ) %>% 
    mutate(
      COOP_PROP_OF_ACCSS_COCOA = 100 * COOP_COCOA_HA / sum(COOP_COCOA_HA), 
      COOP_PROP_OF_ACCSS_FOREST = 100 * COOP_FOREST_HA / sum(COOP_FOREST_HA), 
      COOP_PROP_OF_ACCSS_DENSEFOREST = 100 * COOP_DENSEFOREST_HA / sum(COOP_DENSEFOREST_HA), 
      COOP_PROP_OF_ACCSS_OTHERFOREST = 100 * COOP_OTHERFORESTS_HA / sum(COOP_OTHERFORESTS_HA), 
      COOP_PROP_OF_ACCSS_ALL_CD = 100 * COOP_ALL_CD_HA / sum(COOP_ALL_CD_HA), 
      COOP_PROP_OF_ACCSS_OLD_CD = 100 * COOP_OLD_CD_HA / sum(COOP_OLD_CD_HA), 
      COOP_PROP_OF_ACCSS_REC_CD = 100 * COOP_REC_CD_HA / sum(COOP_REC_CD_HA), 
      COOP_PROP_OF_ACCSS_NDDEP = 100 * COOP_NDDEP_HA / sum(COOP_NDDEP_HA), 
      
      COOP_ALL_ANNUAL_CD_HA = COOP_ALL_CD_HA / 16 # that's the 16 years when we have counted cocoa deforestation
    )
}

```

## IDCSS LUs
### Normalize link probabilities - coop perspective
```{r}
links = 
  links %>% 
  group_by(LINK_POTENTIAL_COOP_ID) %>%
  mutate(
    # na.rm to account for cells outside AOA
    LINK_AREA_COOPNORMALISING_SUM = sum(LINK_AREA_HA, na.rm = TRUE),
    LINK_COCOA_COOPNORMALISING_SUM = sum(LINK_COCOA_HA, na.rm = TRUE),
    LINK_FOREST_COOPNORMALISING_SUM = sum(LINK_FOREST_HA, na.rm = TRUE),
    LINK_NDDEP_COOPNORMALISING_SUM = sum(LINK_NDDEP_HA, na.rm = TRUE)
    # across(
    # .cols = starts_with("LINK_") & ends_with("_HA"), 
    # .fns = sum, 
    # .cols = paste0("{.col}","COOPNORMALISING_SUM"))
  ) %>% 
  ungroup() %>% 
  mutate(
    # In empty supply sheds, where not any potential link is predicted to exist, the normalising sum is 0. In this case, give set values to 0.  
    LINK_AREA_HA_COOPNORMED = case_when(
      LINK_AREA_COOPNORMALISING_SUM > 0 ~ LINK_AREA_HA / LINK_AREA_COOPNORMALISING_SUM,
      TRUE ~ 0 
      ),
    LINK_COCOA_HA_COOPNORMED = case_when(
      LINK_COCOA_COOPNORMALISING_SUM > 0 ~ LINK_COCOA_HA / LINK_COCOA_COOPNORMALISING_SUM,
      TRUE ~ 0
      ),
    LINK_FOREST_HA_COOPNORMED = case_when(
      LINK_FOREST_COOPNORMALISING_SUM > 0 ~ LINK_FOREST_HA / LINK_FOREST_COOPNORMALISING_SUM,
      TRUE ~ 0
      ),
    LINK_NDDEP_HA_COOPNORMED = case_when(
      LINK_NDDEP_COOPNORMALISING_SUM > 0 ~ LINK_NDDEP_HA / LINK_NDDEP_COOPNORMALISING_SUM, 
      TRUE ~ 0
      )
    # across(
    # .cols = starts_with("LINK_") & ends_with("_HA"), 
    # .fns = {.col} / paste0("{.col}","COOPNORMALISING_SUM"), 
    # .cols = )
  ) 


# Sort links by normalised proba within coop 
links = 
  links %>% 
  group_by(LINK_POTENTIAL_COOP_ID) %>% 
  arrange(desc(LINK_AREA_HA_COOPNORMED)) %>% 
  mutate(LINK_AREA_HA_COOPNORMED_cumsum = cumsum(LINK_AREA_HA_COOPNORMED), 
         LINK_AREA_IS_TOP_80PCT_COOP = (LINK_AREA_HA_COOPNORMED_cumsum <= 0.8)) %>% 
  ungroup() %>% 
  group_by(LINK_POTENTIAL_COOP_ID) %>% 
  arrange(desc(LINK_COCOA_HA_COOPNORMED)) %>% 
  mutate(LINK_COCOA_HA_COOPNORMED_cumsum = cumsum(LINK_COCOA_HA_COOPNORMED), 
         LINK_COCOA_IS_TOP_80PCT_COOP = (LINK_COCOA_HA_COOPNORMED_cumsum <= 0.8)) %>% 
  ungroup() %>% 
  group_by(LINK_POTENTIAL_COOP_ID) %>% 
  arrange(desc(LINK_FOREST_HA_COOPNORMED)) %>% 
  mutate(LINK_FOREST_HA_COOPNORMED_cumsum = cumsum(LINK_FOREST_HA_COOPNORMED), 
         LINK_FOREST_IS_TOP_80PCT_COOP = (LINK_FOREST_HA_COOPNORMED_cumsum <= 0.8)) %>% 
  ungroup() %>% 
  group_by(LINK_POTENTIAL_COOP_ID) %>% 
  arrange(desc(LINK_NDDEP_HA_COOPNORMED)) %>% 
  mutate(LINK_NDDEP_HA_COOPNORMED_cumsum = cumsum(LINK_NDDEP_HA_COOPNORMED), 
         LINK_NDDEP_IS_TOP_80PCT_COOP = (LINK_NDDEP_HA_COOPNORMED_cumsum <= 0.8)) %>% 
  ungroup() 

links %>% filter(LINK_POTENTIAL_COOP_ID == "COOP-1000")arrange(desc(LINK_COCOA_HA_COOPNORMED)) %>% 
 select(LINK_POTENTIAL_COOP_ID, starts_with("LINK_COCOA")) %>% View()

```


### Discretize unconditional probabilities
```{r}
# Not sure this is going to be useful... 
# fn_idcss_lus = function(links_data, link_proba_normed_var){
#   linked_coops = 
#     links_data %>% 
#     mutate()
#     # remove cells outside AOA).   
#     filter(!is.na(CELL_SHARE_COOP)) %>% 
#     # remove coops without any potential link predicted with positive proba. 
#     group_by(LINK_POTENTIAL_COOP_ID) %>% 
#     filter(any(LINK_PROBA_THRESH > 0)) %>%
#     ungroup() %>% 
#     summarise(.by = "LINK_POTENTIAL_COOP_ID", 
#               COOP_AREA_HA =            sum(cell_area_ha            * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_COCOA_HA =           sum(CELL_COCOA_HA           * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_FOREST_HA =          sum(CELL_FOREST_HA          * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_DENSEFOREST_HA =     sum(CELL_DENSEFOREST_HA     * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_OTHERFORESTS_HA =    sum(CELL_OTHERFORESTS_HA    * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_ALL_CD_HA =          sum(CELL_ALL_CD_HA          * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_OLD_CD_HA =          sum(CELL_OLD_CD_HA          * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_REC_CD_HA =          sum(CELL_REC_CD_HA          * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0)),
#               COOP_NDDEP_HA = sum(CELL_NDDEP_HA * (CELL_SHARE_COOP * LINK_IS_TOP_80PCT > 0))
#     )
# }
```


## Transformations for display
```{r}
cells_toplot = 
  cells %>% 
  mutate(
   # Work on PERCENTAGE, not share, from here, for display. 
    CELL_SHARE_COOP = 100*CELL_SHARE_COOP,
    CELL_COCOA_SHARE = 100*CELL_COCOA_SHARE, 
    CELL_FOREST_SHARE = 100*CELL_FOREST_SHARE, 
    CELL_DENSEFOREST_SHARE = 100*CELL_DENSEFOREST_SHARE, 
    CELL_OTHERFORESTS_SHARE = 100*CELL_OTHERFORESTS_SHARE, 
    CELL_NDDEP_SHARE = 100*CELL_NDDEP_SHARE, 
    # Round hectares
    across(.cols = ends_with("_HA"), .fns = ~.x/1000), # replaces all the variables ending with _HA
    across(.cols = ends_with("_HA"), .fns = ~round(.x, 1)) 
    # across(.cols = ends_with("_HA"), .fns = ~round(.x, 0)), 
    )
names(cells_toplot) <- gsub("_HA", "_KHA", names(cells_toplot))
summary(cells$CELL_COCOA_HA)
summary(cells_toplot$CELL_COCOA_KHA)

# Just add it back for deforestation
cells_toplot = cells_toplot %>% left_join(cells %>% select(CELL_ID, CELL_ALL_CD_HA), by = "CELL_ID")


```
# 5.1. PROFILING


## 5.1.1. Descriptive statistics 
Distribution of ICCSS in terms of total land
(Max distance with positive proba.)

```{r}
iccss = 
  fn_iccss_lus(links_data = links, link_proba_normed_var = "LINK_PROBA_THRESH_NORMED")

iccss$COOP_AREA_HA %>% summary()
quantile(iccss$COOP_AREA_HA, seq(0,1,0.1))

# Calculate the cumulative sum of COOP_AREA_HA
iccss <- iccss %>%
  arrange(desc(COOP_AREA_HA))
iccss <- iccss %>%
  mutate(COOP_AREA_HA_cumulative_sum = cumsum(COOP_AREA_HA))
# Calculate the total sum 
total_sum <- sum(iccss$COOP_AREA_HA)
# Calculate the cumulative percentage of COOP_AREA_HA
iccss <- iccss %>%
  mutate(
    COOP_AREA_RANK_cumulative_percentage        = 100*COOP_AREA_HA_cumulative_sum / total_sum, 
    COOP_AREA_RANK = case_when(
       COOP_AREA_RANK_cumulative_percentage < 20 ~ "Top 20%",
       COOP_AREA_RANK_cumulative_percentage >= 20 & COOP_AREA_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_AREA_RANK_cumulative_percentage >= 80 ~ "Bottom 20%"
       )
    )
iccss$COOP_AREA_RANK %>% table()

```


## 5.1.2. Case studies
Map 
Look at special cases 
- Coops with very large ICCSS
- Coops with many farmers
- Coops with very small ICCSS
- Coops with few farmers 
- Coops with multiple BS
- Coops clustered together (in cities)

Prepare
```{r}
# This excludes coops with no positive predicted link.
linked_coops = 
  fn_iccss_lus(links_data = links, link_proba_normed_var = "LINK_PROBA_THRESH_NORMED")

# Merge coop data and spatialize
coop22_iccss_sf = 
  coop22_sf %>%  
  left_join(linked_coops, 
            by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID)) 

coop22_iccss_sf$COOP_AREA_HA %>% sum()
```
Largest ones
```{r}
linked_coops$COOP_AREA_HA %>% summary()
quantile(linked_coops$COOP_AREA_HA, seq(0,1,0.1))
xtop = 5

toptotal_coops_sf = 
  coop22_iccss_sf %>% 
  arrange(desc(COOP_AREA_HA)) %>% 
  head(xtop)

top_total_cells_sf = 
  links %>% 
  mutate(COOP_ID = LINK_POTENTIAL_COOP_ID) %>% 
  # Represent discrete supply sheds by the cells making the top 80% of the LU in each ICCSS 
  filter(LINK_AREA_IS_TOP_80PCT_COOP > 0) %>% 
  inner_join(
    toptotal_coops_sf %>% st_drop_geometry(), 
    by = "COOP_ID"
  ) %>% 
  # Spatialize
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  st_buffer(dist = 1e3*MODEL_RESOLUTION_KM/2) 
  # mutate(geometry = st_sfc(st_as_sfc(st_bbox(geometry)), crs = civ_crs)) %>% 

# make square shape of cells
st_geometry(top_total_cells_sf) <- 
  sapply(st_geometry(top_total_cells_sf), FUN = function(x){st_as_sfc(st_bbox(x))}) %>% st_sfc(crs = civ_crs)
top_total_cells_sf %>% st_geometry() %>% plot()

# Values at top coops
top_total_cells_sf %>% arrange(desc(COOP_AREA_HA)) %>% pull(COOP_AREA_HA) %>% unique()
# Values in cells
top_total_cells_sf$LINK_AREA_HA %>% summary()
top_total_cells_sf$LINK_PROBA_THRESH_UNCOND %>% summary()

total_topcoops_plot = 
  ggplot() +
  # Plot the unconditional probability rather than the total area (which is equivalent in spatial relativity, but is more intuitive to see at this point). 
  geom_sf(data = top_total_cells_sf, aes(fill = LINK_PROBA_THRESH_UNCOND, col = LINK_PROBA_THRESH_UNCOND)) + 
  scale_fill_viridis_c(na.value = "transparent", name = "",
                       labels=unit_format(unit = "%", scale = 100, sep = ""), 
                       option = "mako") +
 scale_color_viridis_c(na.value = "transparent", name = "",
                     labels=unit_format(unit = "ha", sep = ""), 
                     option = "mako") +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  geom_sf(data = toptotal_coops_sf, col = "red", size = 0.8) +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "",
    subtitle = ""
  ) + guides(color = "none")
# + guides(size=guide_legend(title="Relative to all cooperatives"))
total_topcoops_plot

ggsave(
  plot = total_topcoops_plot,
  filename = paste0("total_topcoops_plot.png"),
  path = here("outputs", "individual_sheds"),
  width = 25,
  height = 20,
  units = "cm")

```


Smallest ones
```{r}
linked_coops$COOP_AREA_HA %>% summary()
quantile(linked_coops$COOP_AREA_HA, seq(0,1,0.1))
xbot = 5

bottotal_coops_sf = 
  coop22_iccss_sf %>% 
  arrange(COOP_AREA_HA) %>% # ABSENCE OF "desc()" IS THE ONLY THING CHANGING COMPARED TO ABOVE
  head(xbot)

bot_total_cells_sf = 
  links %>% 
  mutate(COOP_ID = LINK_POTENTIAL_COOP_ID) %>% 
  # DO NOT filter to the cells making the top 80% of the LU in each ICCSS, because this excludes every cell for these coops, which supply sheds are made of one cell making alone more than 80%.  
  inner_join(
    bottotal_coops_sf %>% st_drop_geometry(), 
    by = "COOP_ID"
  ) %>% 
  # Spatialize
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  st_buffer(dist = 1e3*MODEL_RESOLUTION_KM/2) 
  # mutate(geometry = st_sfc(st_as_sfc(st_bbox(geometry)), crs = civ_crs)) %>% 

# make square shape of cells
st_geometry(bot_total_cells_sf) <- 
  sapply(st_geometry(bot_total_cells_sf), FUN = function(x){st_as_sfc(st_bbox(x))}) %>% st_sfc(crs = civ_crs)

# Values at bottom coops
bot_total_cells_sf %>% arrange(desc(COOP_AREA_HA)) %>% pull(COOP_AREA_HA) %>% unique()
# Values in cells
bot_total_cells_sf$LINK_AREA_HA %>% summary()
bot_total_cells_sf$LINK_PROBA_THRESH_UNCOND %>% summary()

total_botcoops_plot = 
  ggplot() +
  # Plot the unconditional probability rather than the total area (which is equivalent in spatial relativity, but is more intuitive to see at this point). 
  geom_sf(data = bot_total_cells_sf, aes(fill = LINK_PROBA_THRESH_UNCOND, col = LINK_PROBA_THRESH_UNCOND)) + 
  scale_fill_viridis_c(na.value = "transparent", name = "",
                       labels=unit_format(unit = "%", scale = 100, sep = ""), 
                       option = "mako") +
 scale_color_viridis_c(na.value = "transparent", name = "",
                     labels=unit_format(unit = "ha", sep = ""), 
                     option = "mako") +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  geom_sf(data = bottotal_coops_sf, col = "red", size = 0.8) +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "",
    subtitle = ""
  ) + guides(color = "none")
# + guides(size=guide_legend(title="Relative to all cooperatives"))
total_botcoops_plot

ggsave(
  plot = total_botcoops_plot,
  filename = paste0("total_bottomcoops_plot.png"),
  path = here("outputs", "individual_sheds"),
  width = 25,
  height = 20,
  units = "cm")

```

## 5.1.3. Heuristics

### IoU 
Using link representation, not actual polygons. We determine, for every link, whether it exists under a given heuristic distance or not. 
```{r}
# Formulate the IoU for the current probability threshold and a given heuristic distance. 
# heur_link_proba_var = "LINK_PROBA_H30KM"
fn_IoU_atlink = function(heur_link_proba_var){
  linked_coops =
    links %>% 
    # remove cells outside AOA).   
    filter(!is.na(CELL_SHARE_COOP)) %>% 
    # remove coops without any potential link predicted with positive proba. 
    group_by(LINK_POTENTIAL_COOP_ID) %>% 
    filter(any(LINK_PROBA_THRESH > 0)) %>%
    ungroup() %>% 
    summarise(.by = "LINK_POTENTIAL_COOP_ID", 
      # COOP_IOU_notnorm := sum(LINK_PROBA_THRESH > 0 & !!as.symbol(heur_link_proba_var) > 0) /
      #                     sum(LINK_PROBA_THRESH > 0 | !!as.symbol(heur_link_proba_var) > 0),
      
      COOP_IOU := sum((CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED) > 0 & !!as.symbol(heur_link_proba_var) > 0) /
                  sum((CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED) > 0 | !!as.symbol(heur_link_proba_var) > 0),
      
      COOP_N_CELLS_MODEL = sum(LINK_PROBA_THRESH > 0),
      COOP_N_CELLS_MODEL_NORMED = sum(LINK_PROBA_THRESH_NORMED > 0),
      COOP_N_CELLS_MODEL_UNCOND_NORMED = sum((CELL_SHARE_COOP * LINK_PROBA_THRESH_NORMED) > 0)
    )
  return(linked_coops$COOP_IOU)
}

# Run the function across a vector of heuristic distances. 
IoU_list = list()
for(heuristics_dist_km in all_heuristics_dist_km){
  # match(heuristics_dist_km, all_heuristics_dist_km) %>% print()
  IoU_list[[match(heuristics_dist_km, all_heuristics_dist_km)]] =
    fn_IoU_atlink(
      heur_link_proba_var = paste0("LINK_PROBA_H",heuristics_dist_km,"KM")
    )
}

# Plot the average across coops and CI95%. 

names(IoU_list) = str_pad(as.character(all_heuristics_dist_km), width = 2, side = "left", pad = "0")
IoU_list %>% lengths()
# Create a data frame with the means, lower, and upper bounds of the confidence intervals
mean_data <- data.frame(
  name = names(IoU_list),
  mean_value = sapply(IoU_list, mean),
  lower_bound = sapply(IoU_list, function(x) mean(x) - qt(0.975, length(x)-1) * sd(x) / sqrt(length(x))),
  upper_bound = sapply(IoU_list, function(x) mean(x) + qt(0.975, length(x)-1) * sd(x) / sqrt(length(x)))
)

ggplot(mean_data, aes(x = name, y = mean_value, group = 1)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower_bound, ymax = upper_bound), alpha = 0.2) +
  labs(title = "Mean and 95% Confidence Interval of Each Vector in IoU_list",
       x = "List Element Name",
       y = "Value") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))



links$LINK_PROBA %>% summary()
links$LINK_PROBA_THRESH %>% summary()
# links_topredict$LINK_PROBA %>% summary()
# links_topredict$LINK_PROBA_THRESH %>% summary()
quantile(links$LINK_PROBA_THRESH, seq(0, 1, 0.1), na.rm = T)
quantile(links$LINK_PROBA_THRESH, seq(0.9, 1, 0.01), na.rm = T)
liklink = links %>% filter(LINK_PROBA_THRESH > 0) 
liklink$LINK_POTENTIAL_COOP_ID %>% unique() %>% length()


linked_coops$COOP_IOU %>% summary()
linked_coops$COOP_N_CELLS_MODEL %>% summary()
linked_coops %>% filter(COOP_N_CELLS_MODEL > 0)
linked_coops$COOP_N_CELLS_MODEL_NORMED %>% summary()
quantile(linked_coops$COOP_N_CELLS_MODEL, seq(0, 1, 0.1), na.rm = T)
quantile(linked_coops$COOP_N_CELLS_MODEL_NORMED, seq(0, 1, 0.1), na.rm = T)

```



### Total area
```{r}
quantile(linked_coops$COOP_AREA_HA, seq(0,1,0.1))

# Calculate the cumulative sum of COOP_AREA_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_AREA_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_AREA_HA_cumulative_sum = cumsum(COOP_AREA_HA))

# Calculate the total sum 
total_sum <- sum(linked_coops$COOP_AREA_HA)

# Calculate the cumulative percentage of COOP_AREA_HA
linked_coops <- linked_coops %>%
  mutate(
    COOP_AREA_RANK_cumulative_percentage        = 100*COOP_AREA_HA_cumulative_sum / total_sum, 
    COOP_AREA_RANK = case_when(
       COOP_AREA_RANK_cumulative_percentage < 20 ~ "Top 20%",
       COOP_AREA_RANK_cumulative_percentage >= 20 & COOP_AREA_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_AREA_RANK_cumulative_percentage >= 80 ~ "Bottom 20%"
       )
    )
    
linked_coops$COOP_AREA_RANK %>% table()

# Determine the number of observations in each decile
deciles <- seq(10, 100, by = 10)

# model
decile_counts <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_AREA_RANK_cumulative_percentage <= d)
})
decile_results <- data.frame(
  Decile = deciles,
  Count = decile_counts
)


decile_results

coops_toplot = 
  coop22_sf %>% 
  left_join(linked_coops %>% select(COOP_AREA_HA, COOP_AREA_RANK, LINK_POTENTIAL_COOP_ID), 
            by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID)) %>% 
  arrange(desc(COOP_AREA_HA))

# the supply sheds of only 9 cooperatives include 20% of the remaining dense forest in all cooperative supply sheds. 
100*decile_results[2,"Count"]/nrow(coops_toplot)

coops_toplot = 
  coops_toplot %>% 
  mutate(
    COOP_AREA_RANK = factor(COOP_AREA_RANK, levels = c("Bottom 20%","20-80%","Top 20%")))

map_hotspot_coops_totalarea = 
 ggplot(coops_toplot) +
  geom_sf(mapping = aes(size = COOP_AREA_RANK, fill = COOP_AREA_HA),
         shape = 21) + #, col = COOP_AREA_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Bottom 20%" = 0.1,"20-80%" = 1,"Top 20%" = 4)
                    ) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Hotspots of total area in individual PCSS",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

```

## 5.1.4. Feature importance and explanation
All things variable importance and explanation here. 

Regression of ICCSS on coop attributes 

# 5.2. DOCUMENTING
## 5.2.1. ACCSS 
This uses mostly first stage results. 

### Outside vs. Within

#### Aggregate numbers

```{r}
# The area of each LU category WITHIN the aggregate sourcing shed: 
fn_aggregate_lu = function(out_or_in_share){
  cells %>%
  summarise(.by = CELL_IS_IN_AOA, # this is to summarise over all obs, because non-AOA cells have been remove in previous script already.
            `N CELLS` = sum({{out_or_in_share}}>0), # this will probably be removed eventually
            TOTAL          = round(sum({{out_or_in_share}}*cell_area_ha) / 1000, 1),
            COCOA          = round(sum({{out_or_in_share}}*CELL_COCOA_HA) / 1000, 1),
            FOREST         = round(sum({{out_or_in_share}}*CELL_FOREST_HA) / 1000, 1),
            `DENSE FOREST` = round(sum({{out_or_in_share}}*CELL_DENSEFOREST_HA) / 1000, 1),
            `OTHER FORESTS` = round(sum({{out_or_in_share}}*CELL_OTHERFORESTS_HA) / 1000, 1),
            `OTHER AGRICULTURAL LAND` = round(sum({{out_or_in_share}}*CELL_NDDEP_HA) / 1000, 1), 
            `COCOA DEFORESTATION`          = round(sum({{out_or_in_share}}*CELL_ALL_CD_HA) / 1000, 1)
            ) %>% 
  filter(CELL_IS_IN_AOA) %>% 
  select(-CELL_IS_IN_AOA)
}

fn_aggregate_lu_relative = function(out_or_in_share){
  cells %>%
  summarise(.by = CELL_IS_IN_AOA, 
            `N CELLS` = "", # this will probably be removed eventually
            TOTAL          = 100*round(sum({{out_or_in_share}}*cell_area_ha) / (cell_area_ha*nrow(cells)), 2),
            COCOA          = 100*round(sum({{out_or_in_share}}*CELL_COCOA_HA) / sum(CELL_COCOA_HA), 2),
            FOREST         = 100*round(sum({{out_or_in_share}}*CELL_FOREST_HA) / sum(CELL_FOREST_HA), 1),
            `DENSE FOREST` = 100*round(sum({{out_or_in_share}}*CELL_DENSEFOREST_HA) / sum(CELL_DENSEFOREST_HA), 2),
            `OTHER FORESTS` = 100*round(sum({{out_or_in_share}}*CELL_OTHERFORESTS_HA) / sum(CELL_OTHERFORESTS_HA), 2),
            `OTHER AGRICULTURAL LAND` = 100*round(sum({{out_or_in_share}}*CELL_NDDEP_HA) / sum(CELL_NDDEP_HA), 2),
            `COCOA DEFORESTATION`          = 100*round(sum({{out_or_in_share}}*CELL_ALL_CD_HA) / sum(CELL_ALL_CD_HA), 2)
            ) %>% 
  filter(CELL_IS_IN_AOA) %>% 
  select(-CELL_IS_IN_AOA)
}

aggr_tbl = 
  rbind(
    fn_aggregate_lu(CELL_SHARE_COOP) %>% 
      mutate(` ` = "Within (kha)", .before = everything()),
    fn_aggregate_lu_relative(CELL_SHARE_COOP) %>% 
      mutate(` ` = "Within (%)", .before = everything()),
    fn_aggregate_lu(CELL_1minusSHARE_COOP) %>% 
      mutate(` ` = "Outside (kha)", .before = everything())
  )
  
aggr_tbl

# Create table with kableExtra and add indentation
out_tbl <- 
  aggr_tbl %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Arial") %>% 
  # column_spec(1, width = "4.7cm") %>% # that's to cut nicely $
  column_spec(1, width = "5cm") 

out_tbl

# save_kable(out_tbl, here("outputs", "aggregate_sheds", "LU_in_out.png"))

# Calculate the total LU in the ACCSS
# cells = 
#   cells %>% 
#   mutate(CELL_COCOA_CSS_HA           = CELL_SHARE_COOP*CELL_COCOA_HA ,
#          CELL_FOREST_CSS_HA          = CELL_SHARE_COOP*CELL_FOREST_HA, 
#          CELL_DENSEFOREST_CSS_HA     = CELL_SHARE_COOP*CELL_DENSEFOREST_HA, 
#          CELL_ALL_CD_CSS_HA          = CELL_SHARE_COOP*CELL_ALL_CD_HA, 
#          CELL_NDDEP_CSS_HA = CELL_SHARE_COOP*CELL_NDDEP_HA)
# 
# (cocoa_accss = cells$CELL_COCOA_CSS_HA %>% sum())
# (all_cd_accss = cells$CELL_ALL_CD_CSS_HA %>% sum())
# (nodef_accss = cells$CELL_NDDEP_CSS_HA %>% sum())
# (forest_accss = cells$CELL_FOREST_CSS_HA %>% sum())
# (denseforest_accss = cells$CELL_DENSEFOREST_CSS_HA %>% sum())

```


#### Univariate map
Decide to have 3 or 4 bins in the end, based on final data. 
```{r}
# cells_toplot$CELL_COCOA_SHARE %>% summary()
# cells_toplot$CELL_COCOA_HA %>% summary()
# cells_toplot$CELL_SHARE_COOP %>% summary()
# cells_toplot$CELL_SHARE_COOP %>% quantile(seq(0, 1, 0.1), na.rm = T)

cells_toplot = 
  cells_toplot %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs) 

# Max share of coop outlet, rounded up for clean display
max_share_coop = round(max(cells_toplot$CELL_SHARE_COOP, na.rm = TRUE)+5,-1)

# Depending on final results, choose to show in 3 or 4 bins
break_values = c(0,15,45,max_share_coop)
bin_names = c("0-15%", "15-45%", paste0("45-",max_share_coop,"%"))

# Custom breaks bc we want the lowest bin to be 0 only. 
cells_toplot$`Cooperative outlet (%)` = 
  cut(cells_toplot$CELL_SHARE_COOP, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      include.lowest = TRUE,
      breaks = break_values, 
      labels = bin_names
      )

cells_toplot$`Cooperative outlet (%)` %>% table()

# Make palette with same colors as in the bivariate map
uni_in_bi_pal_outlet = 
  bi_pal("BlueOr", dim = 3, preview = F)
uni_in_bi_pal_outlet = uni_in_bi_pal_outlet[grepl("1-", names(uni_in_bi_pal_outlet))]
names(uni_in_bi_pal_outlet) = bin_names
uni_in_bi_pal_outlet

map =
  ggplot(cells_toplot) +
  geom_sf(mapping = aes(fill = `Cooperative outlet (%)`, col = `Cooperative outlet (%)`),
          size = 1, shape = 22) + #
  scale_fill_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  scale_colour_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  
   # geom_sf(mapping = aes(fill = CELL_SHARE_COOP, col = CELL_SHARE_COOP), 
   #        size = 1, shape = 22) + # 
  
  geom_sf(data = coopbs22_sf, col = "black", size = 0.7) +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Cooperative outlet",
    subtitle = ""
  ) 

map

ggsave(
  plot = map,
  filename = paste0("cooperative_outlet.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 25,
  height = 20,
  units = "cm")
```



#### Bivariate maps
Use biscale package. Different vignettes, including on available bivariate palettes here: 
https://cran.r-project.org/web/packages/biscale/index.html

Use palettes with blue: BlueGold, BlueYl (similar), BlueOr, DkViolet2

##### Cocoa x share
BlueYl
```{r}
cells_toplot$CELL_COCOA_SHARE %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_COCOA_SHARE,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_COCOA_SHARE,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "BlueYl", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "BlueYl", dim = 3, na.value = "transparent") +
  # labs(
  #   title = "Cooperative outlet and cocoa extent",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "BlueYl",
                    dim = 3,
                    xlab = "Cocoa area (%)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)
# element_text(
#   face = "bold",
#   size = 10
#       ), 
                    
cocoa_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

cocoa_bivplot

ggsave(
  plot = cocoa_bivplot,
  filename = paste0("cocoa_bivplot.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 25,
  height = 20,
  units = "cm")

```

##### Forest x share
BlueOr
```{r}
cells_toplot$CELL_FOREST_SHARE %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_FOREST_SHARE,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_FOREST_SHARE,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "BlueOr", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "BlueOr", dim = 3, na.value = "transparent") +
  # labs(
  #   title = "Cooperative outlet and forest extent",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "BlueOr",
                    dim = 3,
                    xlab = "Forest area (%)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

forest_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

forest_bivplot
```

##### Other ag. land x share
DkViolet2
```{r}
cells_toplot$CELL_NDDEP_SHARE %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_NDDEP_SHARE,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_NDDEP_SHARE,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "DkCyan2", dim = 3, na.value = "transparent", flip_axes = TRUE) +
  bi_scale_color(pal = "DkCyan2", dim = 3, na.value = "transparent", flip_axes = TRUE) +
  # labs(
  #   title = "Cooperative outlet and land for potentially sustainable cocoa expansion",
  #   subtitle = ""
  # ) +
  bi_theme()

legend <- bi_legend(pal = "DkCyan2",
                    dim = 3,
                    flip_axes = TRUE,
                    xlab = "Other agricultural land area (%)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

avb_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.15, 1, 1) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.5, height = 0.5)

avb_bivplot
```

##### Multi-panel plot
```{r}
multipanel_bivplot = 
  ggarrange(
    cocoa_bivplot, 
    forest_bivplot,
    avb_bivplot,
    ncol = 3, nrow = 1, 
    common.legend = FALSE, 
    labels = c("A. COCOA EXTENT", "B. FOREST EXTENT", 
               "C. OTHER AGRICULTURAL LAND"), 
    hjust = c(-0.5, -0.5, -0.2), 
    font.label = list(size = 14, color = "black", face = "bold", family = NULL)
    # align = "h"
  ) %>% 
    annotate_figure(top = text_grob("COOPERATIVE OUTLET & ...\n", face = "bold", size = 18))

multipanel_bivplot

ggsave(
  plot = multipanel_bivplot,
  filename = paste0("multipanel_bivplot.png"),
  path = here("outputs", "aggregate_sheds"),
  width = 75,
  height = 50,
  units = "cm")

```

##### Past CD x share
Bluegill
```{r}
cells_toplot$CELL_ALL_CD_HA %>% summary()

# This makes the bivariate bins
cells_toplot = 
  cells_toplot %>% 
  bi_class(CELL_ALL_CD_HA,
            `Cooperative outlet (%)`, 
            dim = 3, 
            style = "quantile", 
            dig_lab = 9)

# This is just for display in the legend
breaks = 
  cells_toplot %>% 
  bi_class_breaks(CELL_ALL_CD_HA,
                  `Cooperative outlet (%)`, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 4, 
                  split = TRUE) 
breaks$bi_y = paste0(break_values, "%")
breaks$bi_x = breaks$bi_x %>% round(0)

map =
  ggplot() +
  geom_sf(data = cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  bi_scale_fill(pal = "GrPink2", dim = 3, na.value = "transparent", flip_axes = FALSE) +
  bi_scale_color(pal = "GrPink2", dim = 3, na.value = "transparent", flip_axes = FALSE) +
  labs(
    title = "PAST COCOA DEFORESTATION",
  ) +
  bi_theme()  + 
    theme(plot.title = element_text(size = 16)) 

legend <- bi_legend(pal = "GrPink2",
                    flip_axes = FALSE,
                    dim = 3,
                    xlab = "Cocoa deforestation (ha)",
                    ylab = "Cooperative outlet (%)",
                    size = 10, 
                    breaks = breaks, 
                    arrows = FALSE)

pastcd_bivplot = 
  ggdraw() +
  draw_plot(map, 0, 0.1, 1, 0.9) +
  draw_plot(legend, x = 0.5, y = 0, width = 0.25, height = 0.25)

pastcd_bivplot

# ggsave(
#   plot = pastcd_bivplot,
#   filename = paste0("pastcd_bivplot.png"),
#   path = here("outputs", "aggregate_sheds"),
#   width = 25,
#   height = 20,
#   units = "cm")
```









### Exclusive vs. Shared
Use same coding as above, but with different bins and palettes  

#### Number of linked coops 
IS THIS THE RIGHT WAY TO COMPUTE IT? I AM NOT SURE 
```{r}
cell_nlinks = 
  links_topredict %>% 
  summarise(.by = "CELL_ID",
            # CELL_N_LINKED_COOPS = sum(LINK_PROBA_THRESH_NORMED_CELLMAX > 0), 
            CELL_N_LINKED_COOPS_ALT = sum(LINK_PROBA_THRESH_NORMED > 0)
            )

cells_topredict = 
  cells_topredict %>% 
  left_join(cell_nlinks, 
             by = "CELL_ID")

cell_nlinks$CELL_N_LINKED_COOPS %>% summary()
cells_topredict$CELL_N_LINKED_COOPS %>% summary()

rm(cell_nlinks)

```


# 5.2.2. HOTSPOTS
This is the hotspot section in the paper.

```{r}
linked_coops = 
  fn_iccss_lus(links_data = links, link_proba_normed_var = "LINK_PROBA_THRESH_NORMED")

stopifnot(
  linked_coops$COOP_PROP_OF_ACCSS_COCOA %>% sum() == 100
)

# Merge coop data and spatialize
coop22_iccss_sf = 
  coop22_sf %>%  
  left_join(linked_coops, 
            by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID)) 

coop22_iccss_sf$COOP_FOREST_HA %>% sum()
coop22_iccss_sf$COOP_PROP_OF_ACCSS_COCOA %>% summary()
coop22_iccss_sf$COOP_PROP_OF_ACCSS_FOREST %>% summary()
coop22_iccss_sf$COOP_PROP_OF_ACCSS_DENSEFOREST %>% summary()
coop22_iccss_sf$COOP_PROP_OF_ACCSS_ALL_CD %>% summary()

```
### Top10 map

```{r}
linked_coops$COOP_COCOA_HA %>% summary()
quantile(linked_coops$COOP_COCOA_HA, seq(0,1,0.1))
xtop = 5

topcocoa_coops_sf = 
  coop22_iccss_sf %>% 
  arrange(desc(COOP_COCOA_HA)) %>% 
  head(xtop)

topforest_coops_sf = 
  coop22_iccss_sf %>% 
  arrange(desc(COOP_FOREST_HA)) %>% 
  head(xtop)

topnddep_coops_sf = 
  coop22_iccss_sf %>% 
  arrange(desc(COOP_NDDEP_HA)) %>% 
  head(xtop)

topcd_coops_sf = 
  coop22_iccss_sf %>% 
  arrange(desc(COOP_ALL_CD_HA)) %>% 
  head(xtop)  

# Is any coop in two or more of these tops?
alltops = 
  topcocoa_coops_sf %>% st_drop_geometry() %>% 
  full_join(
    topforest_coops_sf %>% st_drop_geometry(), 
    by = "COOP_ID") %>% 
  full_join(
    topnddep_coops_sf %>% st_drop_geometry(), 
    by = "COOP_ID") 
nrow(alltops)
names(alltops)

# Currently yes, but let's see with final data. 
intersect(topcocoa_coops_sf$COOP_ID, topforest_coops_sf$COOP_ID)
intersect(topcocoa_coops_sf$COOP_ID, topnddep_coops_sf$COOP_ID)
intersect(topforest_coops_sf$COOP_ID, topnddep_coops_sf$COOP_ID)

top_idcss_cells_sf = 
  links %>% 
  mutate(COOP_ID = LINK_POTENTIAL_COOP_ID) %>% 
  # Spatialize
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  st_buffer(dist = 1e3*MODEL_RESOLUTION_KM/2) 
  # mutate(geometry = st_sfc(st_as_sfc(st_bbox(geometry)), crs = civ_crs)) %>% 

# make square shape of cells
st_geometry(top_idcss_cells_sf) <- 
  sapply(st_geometry(top_idcss_cells_sf), FUN = function(x){st_as_sfc(st_bbox(x))}) %>% st_sfc(crs = civ_crs)
top_idcss_cells_sf %>% st_geometry() %>% plot()

# Split to plot in separate facets - AND BINARIZE
# Top cocoa coops 
cells_top_cocoa_sf = 
  top_idcss_cells_sf %>% 
  # Represent discrete supply sheds by the cells making the top 80% of the LU in each ICCSS 
  filter(LINK_COCOA_IS_TOP_80PCT_COOP > 0) %>% 
  inner_join(
    topcocoa_coops_sf %>% st_drop_geometry(), 
    by = "COOP_ID")

# Top dense forest coops 
cells_top_forest_sf = 
  top_idcss_cells_sf %>% 
  # Represent discrete supply sheds by the cells making the top 80% of the LU in each ICCSS 
  filter(LINK_FOREST_IS_TOP_80PCT_COOP > 0) %>% 
  inner_join(
    topforest_coops_sf %>% st_drop_geometry(), 
    by = "COOP_ID")

# Top NDDEP coops 
cells_top_nddep_sf = 
  top_idcss_cells_sf %>% 
  # Represent discrete supply sheds by the cells making the top 80% of the LU in each ICCSS 
  filter(LINK_NDDEP_IS_TOP_80PCT_COOP > 0) %>% 
  inner_join(
    topnddep_coops_sf %>% st_drop_geometry(), 
    by = "COOP_ID")

# Values at top coops
cells_top_cocoa_sf %>% arrange(desc(COOP_COCOA_HA)) %>% pull(COOP_COCOA_HA) %>% unique()
topcocoa_coops_sf %>% arrange(desc(COOP_COCOA_HA)) %>% pull(COOP_COCOA_HA) %>%  head(10)
# Values in cells
cells_top_cocoa_sf$LINK_COCOA_HA %>% summary()

cocoa_topcoops_plot = 
  ggplot() +
  geom_sf(data = cells_top_cocoa_sf, aes(fill = LINK_COCOA_HA, col = LINK_COCOA_HA)) + 
  scale_fill_viridis_c(na.value = "transparent", name = "",
                       labels=unit_format(unit = "ha", sep = ""), 
                       option = "mako") +
 scale_color_viridis_c(na.value = "transparent", name = "",
                     labels=unit_format(unit = "ha", sep = ""), 
                     option = "mako") +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  geom_sf(data = topcocoa_coops_sf, col = "red", size = 0.8) +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "",
    subtitle = ""
  ) + guides(color = "none")
# + guides(size=guide_legend(title="Relative to all cooperatives"))
cocoa_topcoops_plot

# REMAINING FOREST
forest_topcoops_plot = 
  ggplot() +
  geom_sf(data = cells_top_forest_sf, aes(fill = LINK_FOREST_HA, col = LINK_FOREST_HA)) + 
  scale_fill_viridis_c(na.value = "transparent", name = "",
                       labels=unit_format(unit = "ha", sep = ""), 
                       option = "magma") +
 scale_color_viridis_c(na.value = "transparent", name = "",
                     labels=unit_format(unit = "ha", sep = ""), 
                     option = "magma") +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  geom_sf(data = topforest_coops_sf, col = "red", size = 0.8) +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "",
    subtitle = ""
  ) + guides(color = "none")

# NDDEP
nddep_topcoops_plot = 
  ggplot() +
  geom_sf(data = cells_top_nddep_sf, aes(fill = LINK_NDDEP_HA, col = LINK_NDDEP_HA)) + 
  scale_fill_viridis_c(na.value = "transparent", name = "",
                       labels=unit_format(unit = "ha", sep = ""), 
                       option = "viridis") +
 scale_color_viridis_c(na.value = "transparent", name = "",
                     labels=unit_format(unit = "ha", sep = ""), 
                     option = "viridis") +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  geom_sf(data = coopbs22_sf, col = "black", size = 0.3) +
  geom_sf(data = topnddep_coops_sf, col = "red", size = 0.8) +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "",
    subtitle = ""
  ) + guides(color = "none")

multipanel_hotspots = 
  ggarrange(
    cocoa_topcoops_plot, 
    forest_topcoops_plot,
    nddep_topcoops_plot,
    ncol = 3, nrow = 1, 
    common.legend = FALSE, 
    labels = c("A. COCOA EXTENT", "B. FOREST EXTENT", 
               "C. OTHER AGRICULTURAL LAND"), 
    hjust = c(-0.5, -0.5, -0.2), 
    font.label = list(size = 14, color = "black", face = "bold", family = NULL)
    # align = "h"
  ) %>% 
    annotate_figure(top = text_grob(paste0("HOTSPOTS - SUPPLY SHEDS OF TOP ",xtop, " COOPERATIVES...\n"), face = "bold", size = 18))

multipanel_hotspots

ggsave(
  plot = multipanel_hotspots,
  filename = paste0("multipanel_hotspots.png"),
  path = here("outputs", "individual_sheds"),
  width = 75,
  height = 50,
  units = "cm")

# ---------------------------------------------------------------------------


```


### Violin plots 
```{r}

```


### Hotspots based on cumsum
Cocoa area
```{r}
linked_coops$COOP_AREA_HA %>% summary()
linked_coops$COOP_COCOA_HA %>% summary()

quantile(linked_coops$COOP_COCOA_HA, seq(0,1,0.1))

# Calculate the cumulative sum of COOP_COCOA_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_COCOA_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_COCOA_HA_cumulative_sum = cumsum(COOP_COCOA_HA))

# Calculate the total sum 
total_sum <- sum(linked_coops$COOP_COCOA_HA)

# Calculate the cumulative percentage of COOP_COCOA_HA
linked_coops <- linked_coops %>%
  mutate(
    COOP_COCOA_RANK_cumulative_percentage        = 100*COOP_COCOA_HA_cumulative_sum / total_sum, 
    COOP_COCOA_RANK = case_when(
       COOP_COCOA_RANK_cumulative_percentage < 20 ~ "Top 20%",
       COOP_COCOA_RANK_cumulative_percentage >= 20 & COOP_COCOA_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_COCOA_RANK_cumulative_percentage >= 80 ~ "Bottom 20%"
       )
    )
    
linked_coops$COOP_COCOA_RANK %>% table()

# Determine the number of observations in each decile
deciles <- seq(10, 100, by = 10)

# model
decile_counts <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_COCOA_RANK_cumulative_percentage <= d)
})
decile_results <- data.frame(
  Decile = deciles,
  Count = decile_counts
)


decile_results

coop22_sf = 
  coopbs22_sf %>% 
  # keep only one BS point for plotting this
  distinct(COOP_ID, .keep_all = TRUE) %>% 
  left_join(linked_coops, 
            by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID)) %>% 
  arrange(desc(COOP_COCOA_HA))

# the supply sheds of only 9 cooperatives include 20% of the remaining dense forest in all cooperative supply sheds. 
100*decile_results[2,"Count"]/nrow(coop22_sf)

coop22_sf = 
  coop22_sf %>% 
  mutate(
    COOP_COCOA_RANK = factor(COOP_COCOA_RANK, levels = c("Bottom 20%","20-80%","Top 20%")))

map_hotspot_coops_cocoa = 
 ggplot(coop22_sf) +
  geom_sf(mapping = aes(size = COOP_COCOA_RANK, fill = COOP_COCOA_HA),
         shape = 21) + #, col = COOP_COCOA_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Bottom 20%" = 0.1,"20-80%" = 1,"Top 20%" = 4)
                    ) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

```


Dense forest distribution
```{r}

quantile(linked_coops$COOP_DENSEFOREST_HA, seq(0,1,0.1))
quantile(linked_coops$COOP_PROP_OF_ACCSS_DENSEFOREST, seq(0,1,0.1))

# Calculate the cumulative sum of COOP_DENSEFOREST_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_DENSEFOREST_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_DENSEFOREST_HA_cumulative_sum = cumsum(COOP_DENSEFOREST_HA))

# Calculate the total sum 
total_sum <- sum(linked_coops$COOP_DENSEFOREST_HA)

# Calculate the cumulative percentage of COOP_DENSEFOREST_HA
linked_coops <- linked_coops %>%
  mutate(
    COOP_DENSEFOREST_RANK_cumulative_percentage        = 100*COOP_DENSEFOREST_HA_cumulative_sum / total_sum, 
    COOP_DENSEFOREST_RANK = case_when(
       COOP_DENSEFOREST_RANK_cumulative_percentage < 20 ~ "Top 20%",
       COOP_DENSEFOREST_RANK_cumulative_percentage >= 20 & COOP_DENSEFOREST_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_DENSEFOREST_RANK_cumulative_percentage >= 80 ~ "Bottom 20%"
       )
    )
    
linked_coops$COOP_DENSEFOREST_RANK %>% table()

# Determine the number of observations in each decile
deciles <- seq(10, 100, by = 10)

# model
decile_counts <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_DENSEFOREST_RANK_cumulative_percentage <= d)
})
decile_results <- data.frame(
  Decile = deciles,
  Count = decile_counts
)


decile_results

coop22_sf = 
  coopbs22_sf %>% 
  # keep only one BS point for plotting this
  distinct(COOP_ID, .keep_all = TRUE) %>% 
  left_join(linked_coops, 
            by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID)) %>% 
  arrange(desc(COOP_DENSEFOREST_HA))

# the supply sheds of only 9 cooperatives include 20% of the remaining dense forest in all cooperative supply sheds. 
100*decile_results[2,"Count"]/nrow(coop22_sf)

coop22_sf = 
  coop22_sf %>% 
  mutate(
    COOP_DENSEFOREST_RANK = factor(COOP_DENSEFOREST_RANK, levels = c("Bottom 20%","20-80%","Top 20%")))

map_hotspot_coops_dense_forest = 
 ggplot(coop22_sf) +
  geom_sf(mapping = aes(size = COOP_DENSEFOREST_RANK, fill = COOP_DENSEFOREST_HA),
         shape = 21) + #, col = COOP_DENSEFOREST_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Bottom 20%" = 0.1,"20-80%" = 1,"Top 20%" = 4)
                    ) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Hotspots of remaining dense forest in individual PCSS",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

# ggsave(
#   plot = map_hotspot_coops_dense_forest,
#   filename = paste0("map_hotspot_coops_dense_forest.png"),
#   path = here("outputs", "individual_sheds"),
#   width = 25,
#   height = 20,
#   units = "cm")


```

All CD distribution (comparison with heuristics distribution)
```{r}
# ALL CD (COCOA DEFORESTATION) 

linked_coops_heur_cd = 
  links %>% 
  summarise(.by = "LINK_POTENTIAL_COOP_ID", 
            COOP_ALL_CD_H10KM_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_OLD_CD_H10KM_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
            COOP_REC_CD_H10KM_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H10KM_NORMED),
           
            COOP_ALL_CD_H30KM_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_OLD_CD_H30KM_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),
            COOP_REC_CD_H30KM_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H30KM_NORMED),

            COOP_ALL_CD_H60KM_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_OLD_CD_H60KM_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED),
            COOP_REC_CD_H60KM_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_H60KM_NORMED), 
            
            COOP_ALL_CD_HDISTR_HA =          sum(CELL_ALL_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_OLD_CD_HDISTR_HA =          sum(CELL_OLD_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED),
            COOP_REC_CD_HDISTR_HA =          sum(CELL_REC_CD_HA          * CELL_SHARE_COOP * LINK_PROBA_HDISTR_NORMED)
            )

# CODE (NAMES) NEED TO BE ADJUSTED BELOW

quantile(linked_coops$COOP_ALL_CD_HA, seq(0,1,0.1))
quantile(linked_coops$COOP_PROP_OF_ACCSS_ALL_CD, seq(0,1,0.1))

# Calculate the cumulative sum of COOP_ALL_CD_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_ALL_CD_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_ALL_CD_HA_cumulative_sum = cumsum(COOP_ALL_CD_HA))

# Calculate the cumulative sum of COOP_ALL_CD_H10KM_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_ALL_CD_H10KM_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_ALL_CD_H10KM_HA_cumulative_sum = cumsum(COOP_ALL_CD_H10KM_HA))

# Calculate the cumulative sum of COOP_ALL_CD_HDISTR_HA
linked_coops <- linked_coops %>%
  arrange(desc(COOP_ALL_CD_HDISTR_HA))
linked_coops <- linked_coops %>%
  mutate(COOP_ALL_CD_HDISTR_HA_cumulative_sum = cumsum(COOP_ALL_CD_HDISTR_HA))

# Calculate the total sum 
total_sum <- sum(linked_coops$COOP_ALL_CD_HA)
total_sum_h10km <- sum(linked_coops$COOP_ALL_CD_H10KM_HA)
total_sum_hdistr <- sum(linked_coops$COOP_ALL_CD_HDISTR_HA)

# Calculate the cumulative percentage of COOP_ALL_CD_HA
linked_coops <- linked_coops %>%
  mutate(
    COOP_ALL_CD_RANK_cumulative_percentage        = 100*COOP_ALL_CD_HA_cumulative_sum / total_sum, 
    COOP_ALL_CD_RANK = case_when(
       COOP_ALL_CD_RANK_cumulative_percentage < 20 ~ "Top 20%",
       COOP_ALL_CD_RANK_cumulative_percentage >= 20 & COOP_ALL_CD_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_ALL_CD_RANK_cumulative_percentage >= 80 ~ "Bottom 20%"
       ),
    
    COOP_ALL_CD_H10KM_RANK_cumulative_percentage  = 100*COOP_ALL_CD_H10KM_HA_cumulative_sum / total_sum_h10km,
    COOP_ALL_CD_H10KM_RANK = case_when(
       COOP_ALL_CD_H10KM_RANK_cumulative_percentage < 20 ~ "Top 20%",
       COOP_ALL_CD_H10KM_RANK_cumulative_percentage >= 20 & COOP_ALL_CD_H10KM_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_ALL_CD_H10KM_RANK_cumulative_percentage >= 80 ~ "Bottom 20%"
       ),
    
    COOP_ALL_CD_HDISTR_RANK_cumulative_percentage = 100*COOP_ALL_CD_HDISTR_HA_cumulative_sum / total_sum_hdistr, 
    COOP_ALL_CD_HDISTR_RANK = case_when(
       COOP_ALL_CD_HDISTR_RANK_cumulative_percentage < 20 ~ "Top 20%",
       COOP_ALL_CD_HDISTR_RANK_cumulative_percentage >= 20 & COOP_ALL_CD_HDISTR_RANK_cumulative_percentage < 80 ~ "20-80%", 
       COOP_ALL_CD_HDISTR_RANK_cumulative_percentage >= 80 ~ "Bottom 20%"
       )
         )
linked_coops$COOP_ALL_CD_RANK %>% table()
linked_coops$COOP_ALL_CD_H10KM_RANK %>% table()
linked_coops$COOP_ALL_CD_HDISTR_RANK %>% table()

# Determine the number of observations in each decile
deciles <- seq(10, 100, by = 10)

# model
decile_counts <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_ALL_CD_RANK_cumulative_percentage <= d)
})
decile_results <- data.frame(
  Decile = deciles,
  Count = decile_counts
)

# 10km
decile_counts_h10km <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_ALL_CD_H10KM_RANK_cumulative_percentage <= d)
})
decile_results_h10km <- data.frame(
  Decile = deciles,
  Count = decile_counts_h10km
)
# district
decile_counts_hdistr <- sapply(deciles, function(d) {
  sum(linked_coops$COOP_ALL_CD_HDISTR_RANK_cumulative_percentage <= d)
})
decile_results_hdistr <- data.frame(
  Decile = deciles,
  Count = decile_counts_hdistr
)

decile_results
decile_results_h10km
decile_results_hdistr
# Create the ECDF plot
# ggplot(linked_coops, aes(x = COOP_ALL_CD_HA)) +
#   stat_ecdf(geom = "step", color = "blue") +
#   labs(title = "ECDF Plot of cocoa deforestation in individual PCSS",
#        x = "cocoa deforestation",
#        y = "Cumulative Probability") +
#   theme_minimal()

# Create the violin plot
# ggplot(linked_coops, aes(x = factor(1), y = COOP_ALL_CD_HA)) +
#   geom_violin(fill = "blue", alpha = 0.6) +
#   labs(title = "Violin Plot of of cocoa deforestation in individual PCSS",
#        x = "cocoa deforestation",
#        y = "Density") +
#   theme_minimal()

# bubbles(value = linked_coops$COOP_PROP_OF_ACCSS_ALL_CD, 
#         label = as.character(round(linked_coops$COOP_ALL_ANNUAL_CD_HA, 0)))

coop22_sf = 
  coopbs22_sf %>% 
  # keep only one BS point for plotting this
  distinct(COOP_ID, .keep_all = TRUE) %>% 
  left_join(linked_coops, 
            by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID)) %>% 
  arrange(desc(COOP_ALL_CD_HA))

# 20% of the cocoa deforestation attributable to cooperatives is in the supply sheds of less than 1% of cooperatives.
100*decile_results[2,"Count"]/nrow(coop22_sf)

coop22_sf = 
  coop22_sf %>% 
  mutate(
    COOP_ALL_CD_RANK = factor(COOP_ALL_CD_RANK, levels = c("Bottom 20%","20-80%","Top 20%")),
    COOP_ALL_CD_H10KM_RANK = factor(COOP_ALL_CD_H10KM_RANK, levels = c("Bottom 20%","20-80%","Top 20%")),
    COOP_ALL_CD_HDISTR_RANK = factor(COOP_ALL_CD_HDISTR_RANK, levels = c("Bottom 20%","20-80%","Top 20%")))

map_hotspot_coops_all_cd = 
 ggplot(coop22_sf) +
  geom_sf(mapping = aes(size = COOP_ALL_CD_RANK, fill = COOP_ALL_CD_HA),
         shape = 21) + #, col = COOP_ALL_CD_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Bottom 20%" = 0.1,"20-80%" = 1,"Top 20%" = 4)
                    ) +
  # scale_colour_viridis_c(na.value = "transparent", name = "Absolute",
  #                        labels=unit_format(unit = "ha", sep = "")) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Hotspot cocoa deforestation in individual PCSS",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

ggsave(
  plot = map_hotspot_coops_all_cd,
  filename = paste0("map_hotspot_coops_all_cd.png"),
  path = here("outputs", "individual_sheds"),
  width = 25,
  height = 20,
  units = "cm")



map_hotspot_coops_all_cd_distr = 
 ggplot(coop22_sf) +
  geom_sf(mapping = aes(size = COOP_ALL_CD_HDISTR_RANK, fill = COOP_ALL_CD_HDISTR_HA),
         shape = 21) + #, col = COOP_ALL_CD_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Bottom 20%" = 0.1,"20-80%" = 1,"Top 20%" = 4)
                    ) +
  # scale_colour_viridis_c(na.value = "transparent", name = "Absolute",
  #                        labels=unit_format(unit = "ha", sep = "")) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Hotspot cocoa deforestation in department supply sheds",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

ggsave(
  plot = map_hotspot_coops_all_cd_distr,
  filename = paste0("map_hotspot_coops_all_cd_distr.png"),
  path = here("outputs", "individual_sheds"),
  width = 25,
  height = 20,
  units = "cm")



map_hotspot_coops_all_cd_10km = 
 ggplot(coop22_sf) +
  geom_sf(mapping = aes(size = COOP_ALL_CD_H10KM_RANK, fill = COOP_ALL_CD_H10KM_HA),
         shape = 21) + #, col = COOP_ALL_CD_HA
  
  scale_size_manual(name = "Relative to all cooperatives",
                    # labels=unit_format(unit = "%", sep = "")
                    values = c("Bottom 20%" = 0.1,"20-80%" = 1,"Top 20%" = 4)
                    ) +
  # scale_colour_viridis_c(na.value = "transparent", name = "Absolute",
  #                        labels=unit_format(unit = "ha", sep = "")) +
  scale_fill_viridis_c(na.value = "transparent", name = "Absolute",
                       labels=unit_format(unit = "ha", sep = "")) +
  
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Hotspot cocoa deforestation in 10km supply sheds",
    subtitle = ""
  ) + 
   guides(size=guide_legend(title="Relative to all cooperatives"))

ggsave(
  plot = map_hotspot_coops_all_cd_10km,
  filename = paste0("map_hotspot_coops_all_cd_10km.png"),
  path = here("outputs", "individual_sheds"),
  width = 25,
  height = 20,
  units = "cm")

```




## Map discrete polygons
In addition, for display purposes, add approximate supply shed polygons

We define for every cell to which coop it most likely supplies (conditional on supplying any coop in the first place). 
I.e. we identify the most likely links for every cell. 
This is not completely sharp polygons though (i.e. there are still overlaps), as we still have many equi-probabilities... 

Then, unionize the cell by coop id and merge with linked_coop

```{r}
# Find the max conditional, normalised proba in every cell. 
# Using the unconditional probas would yield exactly the same result, as it just differs by a cell-level quantity, 
# EXCEPT in cells that don't pass the 1st stage threshold. There, unconditional probas would all be null, but conditional probas aren't. So using *conditional* probas allows to also determine which coop is most likely supplied in cells not selling to coops at all. 

links = 
  links %>% 
  group_by(CELL_ID) %>% 
  mutate(
    LINK_PROBA_THRESH_NORMED_CELLMAX = max(LINK_PROBA_THRESH_NORMED), 
  ) %>% 
  ungroup() %>% 
  mutate(LINK_IS_MOST_LIKELY = case_when(
    LINK_PROBA_THRESH_NORMED_CELLMAX == 0 | # where all probas are null
      # or where their maximum is strictly higher than the link's proba, the link is NOT most likely
    LINK_PROBA_THRESH_NORMED_CELLMAX > LINK_PROBA_THRESH_NORMED ~ FALSE, 
    is.na(LINK_PROBA_THRESH_NORMED_CELLMAX) ~ NA,
    TRUE ~ TRUE
    )
  ) %>% 
  group_by(CELL_ID) %>% 
  mutate(CELL_N_MOST_LIKELY_LINKS = sum(LINK_IS_MOST_LIKELY, na.rm = T)) %>% 
  ungroup() 

# Equi-probabilities are allowed. 
# We have them for a few truly predicted probas. 
links %>%   
  filter(CELL_N_MOST_LIKELY_LINKS > 1) %>% 
  arrange(CELL_ID) %>% 
  View()

# Before, we had them for many of the observed links, which predicted probability to exist is 1, and thus normalised probability is 1/n with n is the number of observed links in cell.
# But now these links are merged into one single cell-coop link in the predict set links.  
links %>%   
  filter(CELL_N_MOST_LIKELY_LINKS > 1) %>% 
  filter(!is.na(PRO_ID)) %>% 
  nrow()

links %>%   
  filter(CELL_N_MOST_LIKELY_LINKS == 1) %>% nrow()

links$LINK_IS_MOST_LIKELY %>% summary()
# 2280 cells have a most likely link. This means that in all the other cells, the probabilities to sell to the different coops are all null. 
links %>% filter(LINK_IS_MOST_LIKELY) %>% pull(CELL_ID) %>% unique() %>% length()

# This connects to 275 cooperatives only! 
# It means that a few coops are always the most likely to have a link. 
# IT DOES NOT MEAN THAT THESE ARE THE ONLY COOPS PREDICTED TO HAVE A LINK! 
links %>% filter(LINK_IS_MOST_LIKELY) %>% pull(LINK_POTENTIAL_COOP_ID) %>% unique() %>% length()

# and it's not because we don't have enough information on the 4100 more coops!  
links$LINK_POTENTIAL_COOP_ID %>% unique() %>% length()
links %>% select(all_of(stg2_allfeatures)) %>%  anyNA()
```




Make polygons
```{r}
cell_coop_sheds = 
  links %>% 
  filter(LINK_IS_MOST_LIKELY) %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  st_buffer(dist = 1e3*MODEL_RESOLUTION_KM/2)
stmp = cell_coop_sheds[1,]

# make them square
st_geometry(cell_coop_sheds) <- 
  sapply(st_geometry(cell_coop_sheds), FUN = function(x){st_as_sfc(st_bbox(x))}) %>% st_sfc(crs = civ_crs)

# ggplot() + 
#   geom_sf(data = cell_coop_sheds[1,], fill = "black", col = "black", size = 2) + 
#   geom_sf(data = stmp, col = "red", fill = "red", size = 2)

# Merge cells by coop id to make supply shed of coop 
cell_coop_sheds = 
  cell_coop_sheds %>% 
  summarise(.by = LINK_POTENTIAL_COOP_ID, 
            geometry = st_union(geometry)
            ) %>% 
  rename(COOP_ID = LINK_POTENTIAL_COOP_ID) #%>% 
  # left_join(linked_coops, 
  #           by = "LINK_POTENTIAL_COOP_ID")

ggplot() + 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = cell_coop_sheds, aes(fill = COOP_ID), size = 2) + 
  guides(fill="none")


# Make polygons based on heuristics
coopbs_in_model = 
  coopbs22 %>% 
  filter(COOP_ID %in% cell_coop_sheds$COOP_ID) %>% 
  filter(!is.na(LONGITUDE)) %>% # this removes some buying stations that don't have coordinates, but no coop fully. 
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  select(COOP_ID, geometry) # %>% 
  # left_join(cell_coop_sheds %>% st_drop_geometry(), 
  #           by = join_by(COOP_ID == LINK_POTENTIAL_COOP_ID))

coop_sheds_h10km = 
     coopbs_in_model %>% 
     st_buffer(dist = 10*1e3)
 
coop_sheds_h30km = 
   coopbs_in_model %>% 
   st_buffer(dist = 30*1e3)

coop_sheds_h60km = 
   coopbs_in_model %>% 
   st_buffer(dist = 60*1e3)
 
# names(cell_coop_sheds) = tolower(names(cell_coop_sheds))
# names(cell_coop_sheds) = tolower(names(cell_coop_sheds))
# dir.create(here("temp_data", "individual_coop_supply_sheds", "cell_coop_sheds"), recursive = TRUE) 
# st_write(cell_coop_sheds, here("temp_data", "individual_coop_supply_sheds",
#                                 "cell_coop_sheds",
#                                 "cell_coop_sheds.shp"))
# 
# dir.create(here("temp_data", "individual_coop_supply_sheds", "coop_sheds_h10km"), recursive = TRUE) 
# st_write(coop_sheds_h10km, here("temp_data", "individual_coop_supply_sheds",
#                                 "coop_sheds_h10km", 
#                                 "coop_sheds_h10km.shp"), 
#          append = FALSE)
# 
# dir.create(here("temp_data", "individual_coop_supply_sheds", "coop_sheds_h30km"), recursive = TRUE) 
# write_sf(coop_sheds_h30km, here("temp_data", "individual_coop_supply_sheds",
#                                 "coop_sheds_h30km", 
#                                 "coop_sheds_h30km.shp"))
# 
# dir.create(here("temp_data", "individual_coop_supply_sheds", "coop_sheds_h60km"), recursive = TRUE) 
# write_sf(coop_sheds_h60km, here("temp_data", "individual_coop_supply_sheds",
#                                 "coop_sheds_h60km", 
#                                 "coop_sheds_h60km.shp"))

```


# CELL EXPOSURE TO COOP ATTRIBUTES

## Proba from inverse distance  

```{r}
coop22 = 
  coopbsy %>% 
  filter(YEAR == 2022) %>% 
  # do that to match the output of the model 
  mutate(COOP_ID = paste0("COOP-",COOP_ID)) %>% 
  distinct(COOP_ID, .keep_all = TRUE)

# (in links data, COOP_ID and LINK_POTENTIAL_COOP_ID are actually the same, but use the latter when using links data for consistency)
# links %>% filter(paste0("COOP-", COOP_ID) != LINK_POTENTIAL_COOP_ID) %>% View()

# links %>% 
#   group_by(CELL_ID) %>% 
#   mutate(CELL_WEIGHTS_SUM = sum(LINK_PROBA_THRESH_NORMED)) %>% 
#   ungroup() %>% 
#   pull(CELL_WEIGHTS_SUM) %>% summary()

# join coop attributes to links data - not necessary, everything in links already
# links_coopattr = 
#   links %>% 
#   left_join(coop22, 
#             by = join_by(LINK_POTENTIAL_COOP_ID == COOP_ID))
# nrow(links_coopattr)
# nrow(links)

names(links)[grepl("COOP_", names(links))]
vars_to_distribute = c("COOP_CERTIFIED_OR_SSI", 
                       "COOP_CERTIFIED", "COOP_HAS_SSI",
                       "COOP_RFA", "COOP_UTZ", "COOP_FT", 
                       names(links)[grepl("COOP_SSI_", names(links))],
                       "COOP_OTHER_PROG",
                       # "COOP_N_KNOWN_BUYERS", # do not include this one, not very informative, because oftentimes it is null, and maximum 3 once distributed to cells.  
                       "COOP_STATUS_SCOOPS", "COOP_STATUS_COOPCA")

cell_exp =
  links %>% 
  summarise(.by = CELL_ID, 
            across(.cols = all_of(vars_to_distribute), 
                   .fns = ~sum(.x*LINK_PROBA_HCONTI_NORMED), # THIS IS WHERE IS DETERMINED THE PROBA USED FOR EXPOSURE MEASUREMENT  
                   .names = paste0("PROBA_", "{.col}")), 
            CELL_LONGITUDE = unique(CELL_LONGITUDE),
            CELL_LATITUDE = unique(CELL_LATITUDE)
            )

links_cellproba = 
  links %>% 
  left_join(
    cell_exp, 
    by = "CELL_ID"
  )

links_cellproba %>% 
  select(CELL_ID, LINK_PROBA_THRESH_NORMED, LINK_POTENTIAL_COOP_ID, COOP_CERTIFIED, CELL_PROBA_COOP_CERTIFIED) %>% 
  arrange(CELL_ID, desc(LINK_PROBA_THRESH_NORMED)) %>% 
  View()

# Join to World Bank household bundles (grappes)

wb21 = read.dta13(here("input_data", "WB", "CIV_2021_EHCVM-2_v01_M_STATA14", "s00_me_civ2021.dta"))
wb21 = 
  wb21 %>% 
  st_as_sf(coords = c("GPS__Longitude", "GPS__Latitude"), crs = 4326, remove = FALSE) %>% 
  st_transform(crs = civ_crs)

cell_exp = 
  cell_exp %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  st_buffer(dist = 1e3*MODEL_RESOLUTION_KM/2)

# make them square
st_geometry(cell_exp) <- 
  sapply(st_geometry(cell_exp), FUN = function(x){st_as_sfc(st_bbox(x))}) %>% st_sfc(crs = civ_crs)

cell_exp[1,] %>% st_geometry() %>% plot()

wb21_exp = 
  wb21 %>% 
  st_join(cell_exp, 
          join = st_within)

ggplot() + 
  geom_sf(data = cell_exp, col = "transparent", fill = "lightgrey") +
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = wb21_exp, aes(col = PROBA_COOP_CERTIFIED), size = 1) + 
  scale_colour_viridis_c() +
  theme_trase() +
  guides(fill="none")

wb21_exp =  
  wb21_exp %>% 
  st_drop_geometry()

stopifnot(
wb21_exp %>% filter(PROBA_COOP_CERTIFIED_OR_SSI & !PROBA_COOP_CERTIFIED & !PROBA_COOP_HAS_SSI) %>% nrow() == 0 &

wb21_exp %>% filter(!PROBA_COOP_CERTIFIED_OR_SSI & (PROBA_COOP_CERTIFIED | PROBA_COOP_HAS_SSI)) %>% nrow() == 0
)

save.dta13(wb21_exp, 
           here("temp_data", "food_security_VSS", "s00_me_civ2021_coopVSSvars_invdistproba.dta"))
  

wb21_exp$PROBA_COOP_CERTIFIED %>% summary()
wb21_exp$PROBA_COOP_CERTIFIED_OR_SSI %>% summary()
wb21_exp$PROBA_COOP_HAS_SSI %>% summary()



```



## Proba from model 

```{r}
coop22 = 
  coopbsy %>% 
  filter(YEAR == 2022) %>% 
  # do that to match the output of the model 
  mutate(COOP_ID = paste0("COOP-",COOP_ID)) %>% 
  distinct(COOP_ID, .keep_all = TRUE)

# (in links data, COOP_ID and LINK_POTENTIAL_COOP_ID are actually the same, but use the latter when using links data for consistency)
# links %>% filter(paste0("COOP-", COOP_ID) != LINK_POTENTIAL_COOP_ID) %>% View()

# links %>% 
#   group_by(CELL_ID) %>% 
#   mutate(CELL_WEIGHTS_SUM = sum(LINK_PROBA_THRESH_NORMED)) %>% 
#   ungroup() %>% 
#   pull(CELL_WEIGHTS_SUM) %>% summary()

# join coop attributes to links data - not necessary, everything in links already
# links_coopattr = 
#   links %>% 
#   left_join(coop22, 
#             by = join_by(LINK_POTENTIAL_COOP_ID == COOP_ID))
# nrow(links_coopattr)
# nrow(links)

names(links)[grepl("COOP_", names(links))]
vars_to_distribute = c("COOP_CERTIFIED_OR_SSI", 
                       "COOP_CERTIFIED", "COOP_HAS_SSI",
                       "COOP_RFA", "COOP_UTZ", "COOP_FT", 
                       names(links)[grepl("COOP_SSI_", names(links))],
                       "COOP_OTHER_PROG",
                       # "COOP_N_KNOWN_BUYERS", # do not include this one, not very informative, because oftentimes it is null, and maximum 3 once distributed to cells.  
                       "COOP_STATUS_SCOOPS", "COOP_STATUS_COOPCA")

cell_exp =
  links %>% 
  summarise(.by = CELL_ID, 
            across(.cols = all_of(vars_to_distribute), 
                   .fns = ~sum(.x*LINK_PROBA_THRESH_NORMED), # THIS IS THE DIFFERENCE WITH PREVIOUS CODE BLOCK
                   .names = paste0("PROBA_", "{.col}")), 
            CELL_LONGITUDE = unique(CELL_LONGITUDE),
            CELL_LATITUDE = unique(CELL_LATITUDE)
            )

links_cellproba = 
  links %>% 
  left_join(
    cell_exp, 
    by = "CELL_ID"
  )

links_cellproba %>% 
  select(CELL_ID, LINK_PROBA_THRESH_NORMED, LINK_POTENTIAL_COOP_ID, COOP_CERTIFIED, CELL_PROBA_COOP_CERTIFIED) %>% 
  arrange(CELL_ID, desc(LINK_PROBA_THRESH_NORMED)) %>% 
  View()

# Join to World Bank household bundles (grappes)

wb21 = read.dta13(here("input_data", "WB", "CIV_2021_EHCVM-2_v01_M_STATA14", "s00_me_civ2021.dta"))
wb21 = 
  wb21 %>% 
  st_as_sf(coords = c("GPS__Longitude", "GPS__Latitude"), crs = 4326, remove = FALSE) %>% 
  st_transform(crs = civ_crs)

cell_exp = 
  cell_exp %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(crs = civ_crs) %>% 
  st_buffer(dist = 1e3*MODEL_RESOLUTION_KM/2)

# make them square
st_geometry(cell_exp) <- 
  sapply(st_geometry(cell_exp), FUN = function(x){st_as_sfc(st_bbox(x))}) %>% st_sfc(crs = civ_crs)


cell_exp[1,] %>% st_geometry() %>% plot()
wb21_exp = 
  wb21 %>% 
  st_join(cell_exp, 
          join = st_within)

ggplot() + 
  geom_sf(data = cell_exp, col = "transparent", fill = "lightgrey") +
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  geom_sf(data = wb21_exp, aes(col = PROBA_COOP_CERTIFIED), size = 1) + 
  scale_colour_viridis_c() +
  theme_trase() +
  guides(fill="none")

wb21_exp =  
  wb21_exp %>% 
  st_drop_geometry()

stopifnot(
wb21_exp %>% filter(PROBA_COOP_CERTIFIED_OR_SSI & !PROBA_COOP_CERTIFIED & !PROBA_COOP_HAS_SSI) %>% nrow() == 0 &

wb21_exp %>% filter(!PROBA_COOP_CERTIFIED_OR_SSI & (PROBA_COOP_CERTIFIED | PROBA_COOP_HAS_SSI)) %>% nrow() == 0
)

save.dta13(wb21_exp, 
           here("temp_data", "food_security_VSS", "s00_me_civ2021_coopVSSvars_modelproba.dta"))
  

wb21_exp$PROBA_COOP_CERTIFIED %>% summary()
wb21_exp$PROBA_COOP_CERTIFIED_OR_SSI %>% summary()
wb21_exp$PROBA_COOP_HAS_SSI %>% summary()

```

# Additional stuff 
## Distance map

```{r}
cells_toplot = 
  cells_toplot %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs) 

cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS %>% summary()
# Max share of coop outlet, rounded up for clean display
max_dist = round(max(cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS, na.rm = TRUE)+5,-1)

# Depending on final results, choose to show in 3 or 4 bins
bin_names = c("0-15km", "15-45km", paste0("45-",max_dist,"km"))

# Custom breaks bc we want the lowest bin to be 0 only. 
cells_toplot$`Avg. distance 5 nearest coops (m)` = 
  cut(cells_toplot$CELL_AVG_TRAVEL_METERS_5_NEAREST_COOPS, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      include.lowest = TRUE,
      breaks = c(0,15000,45000,max_dist), 
      labels = bin_names
      )

cells_toplot$`Avg. distance 5 nearest coops (m)` %>% table()

# Make palette with same colors as in the bivariate map
uni_in_bi_pal_outlet = 
  bi_pal("PurpleOr", dim = 3, preview = F)
uni_in_bi_pal_outlet = uni_in_bi_pal_outlet[grepl("1-", names(uni_in_bi_pal_outlet))]
names(uni_in_bi_pal_outlet) = bin_names
uni_in_bi_pal_outlet

map =
  ggplot(cells_toplot) +
  geom_sf(mapping = aes(fill = `Avg. distance 5 nearest coops (m)`, col = `Avg. distance 5 nearest coops (m)`),
          size = 1, shape = 22) + #
  scale_fill_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  scale_colour_manual(values = uni_in_bi_pal_outlet, breaks = bin_names, na.value = "transparent") +
  
   # geom_sf(mapping = aes(fill = CELL_SHARE_COOP, col = CELL_SHARE_COOP), 
   #        size = 1, shape = 22) + # 
  
  geom_sf(data = coopbs22_sf, col = "black", size = 0.7) +
  geom_sf(data = departements, fill = "transparent", col = "black") +
  theme_bw() + 
  # theme(legend.title = "Predicted share of cooperative outlet") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'°W')) +
  scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'°N')) +
  labs(
    title = "Distance to cooperatives",
    subtitle = ""
  ) 

map

```


# Old Stuff
### Discrete map 
```{r}
# Make cell categories
# keep in mind that the purpose of this is a map, not an analysis! 

# Start from link level
links = 
  links %>% 
  mutate(
    CELL_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0, 
     # This is where no cocoa is estimated to be sold to coops, but independent of that, some links with coops are predicted to exist (they pass the threshold). 
    CELL_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0, 
    
    # Productive sourcing sheds: actual, influential and outside 
    CELL_PRODUCTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE",
    CELL_PRODUCTIVE_OUTSIDE = CELL_SHARE_COOP == 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    
    # Prospective sourcing sheds: actual, influential and outside 
    CELL_PROSPECTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_OUTSIDE = CELL_SHARE_COOP == 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 

    
    `Sourcing shed type` = case_when(
      CELL_PRODUCTIVE_SOURCING_SHED_ONLY ~ "Productive, actual",
      CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY ~ "Productive, influential", 
      CELL_PRODUCTIVE_OUTSIDE ~ "Productive, outside",
      CELL_PROSPECTIVE_SOURCING_SHED_ONLY ~ "Prospective, actual",
      CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY ~ "Prospective, influential", 
      CELL_PROSPECTIVE_OUTSIDE ~ "Prospective, outside",

      TRUE ~ NA
    )
    )

# links %>% 
#   filter(is.na(`Sourcing shed type`)) %>% 
#   select(CELL_PRODUCTIVE_SOURCING_SHED_ONLY, CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY, CELL_PROSPECTIVE_SOURCING_SHED_ONLY, CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY) %>% 
#   summary()

cells = 
  cells %>% 
  left_join(
    links %>% select(CELL_ID, `Sourcing shed type`) %>% distinct(CELL_ID, .keep_all = TRUE), 
    by = "CELL_ID", relationship = "many-to-many"
  )
cells$`Sourcing shed type` %>% table()

# Check that we cover all cells we predicted a coop outlet share (i.e. excluding not in AoA)
stopifnot(
cells %>% filter(!is.na(CELL_SHARE_COOP)) %>% nrow() == sum(table(cells$`Sourcing shed type`))
)
```

A discrete map may be misleading though, as it may represent many cells in the actual sourcing shed, while their predicted shares of coop outlet are small and uncertain. 


