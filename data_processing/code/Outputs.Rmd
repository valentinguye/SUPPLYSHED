---
title: "Outputs"
author: "Valentin"
date: "`r Sys.Date()`"
output: 
  html_document:
      self_contained: false
---

# Set up and inputs
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(aws.s3)
aws.signature::use_credentials()
Sys.setenv("AWS_DEFAULT_REGION" = "eu-west-1")


library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)
library(here)
library(tictoc)
library(readstata13)
library(sjmisc)
library(terra) # put it after {raster} such that it superceeds homonym functions. 
library(exactextractr)
library(stars)
library(pals)
library(modelsummary) # necessary to load it after DescTools

library(biscale)
library(cowplot)
library(viridis)

set.seed(8888)

# install.packages("https://cran.r-project.org/src/contrib/Archive/isotree/isotree_0.5.5.tar.gz",
#                  repos = NULL, 
#                  type = "source")

## Functions
# Trase palettes etc. for plots
source(here("code", "theme_trase.R"))

# load in particular the function fn_trader_to_group_names, str_trans, ... 
source(here("code", "USEFUL_STUFF_supplyshedproj.R"))

# use the projected CRS used by BNETD for their 2020 land use map. 
civ_crs <- 32630

MODEL_RESOLUTION_KM = 4
cell_area_ha =(100*MODEL_RESOLUTION_KM^2)

xlabs = c(-8, -6, -4)
ylabs = c(5, 7, 9)

## Assets

coopbsy = read.csv(file = here("temp_data/private_IC2B/IC2B_v2_coop_bs_year.csv"))
coopbs22 = coopbsy %>% filter(YEAR == 2022)

cells = readRDS(here("temp_data", "model", paste0("cells.Rdata"))) 

links = readRDS(here("temp_data", "model", paste0("links.Rdata")))

departements <- read_sf(here("input_data/s3/CIV_DEPARTEMENTS.geojson"))
departements = 
  st_transform(departements, crs = civ_crs)

```



# Aggregate sourcing sheds 
This uses mostly first stage results. 


### Discrete map 
```{r}
# Make cell categories
# keep in mind that the purpose of this is a map, not an analysis! 

# Start from link level
links = 
  links %>% 
  mutate(
    CELL_SOURCING_SHED_ONLY = CELL_SHARE_COOP_SIGNI > 0, 
     # This is where no cocoa is estimated to be sold to coops, but independent of that, some links with coops are predicted to exist (they pass the threshold). 
    CELL_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP_SIGNI == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0, 
    
    # Productive sourcing sheds: actual, influential and outside 
    CELL_PRODUCTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP_SIGNI > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP_SIGNI == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE",
    CELL_PRODUCTIVE_OUTSIDE = CELL_SHARE_COOP_SIGNI == 0 & CELL_PRODUCTION_STATUS == "PRODUCTIVE", 
    
    # Prospective sourcing sheds: actual, influential and outside 
    CELL_PROSPECTIVE_SOURCING_SHED_ONLY = CELL_SHARE_COOP_SIGNI > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY = CELL_SHARE_COOP_SIGNI == 0 & LINK_PROBA_THRESH_NORMED_CELLMAX > 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 
    CELL_PROSPECTIVE_OUTSIDE = CELL_SHARE_COOP_SIGNI == 0 & CELL_PRODUCTION_STATUS == "PROSPECTIVE", 

    
    `Sourcing shed type` = case_when(
      CELL_PRODUCTIVE_SOURCING_SHED_ONLY ~ "Productive, actual",
      CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY ~ "Productive, influential", 
      CELL_PRODUCTIVE_OUTSIDE ~ "Productive, outside",
      CELL_PROSPECTIVE_SOURCING_SHED_ONLY ~ "Prospective, actual",
      CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY ~ "Prospective, influential", 
      CELL_PROSPECTIVE_OUTSIDE ~ "Prospective, outside",

      TRUE ~ NA
    )
    )

# links %>% 
#   filter(is.na(`Sourcing shed type`)) %>% 
#   select(CELL_PRODUCTIVE_SOURCING_SHED_ONLY, CELL_PRODUCTIVE_INFLUENCE_SHED_ONLY, CELL_PROSPECTIVE_SOURCING_SHED_ONLY, CELL_PROSPECTIVE_INFLUENCE_SHED_ONLY) %>% 
#   summary()

cells = 
  cells %>% 
  left_join(
    links %>% select(CELL_ID, `Sourcing shed type`) %>% distinct(CELL_ID, .keep_all = TRUE), 
    by = "CELL_ID", multiple = "all"
  )
cells$`Sourcing shed type` %>% table()

# Check that we cover all cells we predicted a coop outlet share (i.e. excluding not in AoA)
stopifnot(
cells %>% filter(!is.na(CELL_SHARE_COOP)) %>% nrow() == sum(table(cells$`Sourcing shed type`))
)
```

A discrete map may be misleading though, as it may represent many cells in the actual sourcing shed, while their predicted shares of coop outlet are small and uncertain. 

### Continuous map
Use biscale package. Different vignettes, including on available bivariate palettes here: 
https://cran.r-project.org/web/packages/biscale/index.html

```{r}
cells$CELL_COCOA_SHARE %>% summary()
cells$CELL_COCOA_HA %>% summary()
cells$CELL_SHARE_COOP_SIGNI %>% summary()
cells$CELL_SHARE_COOP_SIGNI %>% quantile(seq(0, 1, 0.1), na.rm = T)

cells_toplot = 
  cells %>% 
  st_as_sf(coords = c("CELL_LONGITUDE", "CELL_LATITUDE"), crs = 4326) %>% 
  st_transform(civ_crs)

aoa_cells_toplot = 
  cells_toplot %>% 
  filter(CELL_IS_IN_AOA)

oaoa_cells_toplot = 
  cells_toplot %>% 
  filter(!CELL_IS_IN_AOA)

# Max share of coop outlet, rounded up for clean display
max_share_coop = round(max(aoa_cells_toplot$CELL_SHARE_COOP_SIGNI, na.rm = TRUE)+0.05,1)

# Custom breaks bc we want the lowest bin to be 0 only. 
aoa_cells_toplot$CELL_SHARE_COOP_SIGNI_bin = 
  cut(aoa_cells_toplot$CELL_SHARE_COOP_SIGNI, 
      right = FALSE, # implies [a, b[ intervals
      # by default, right = TRUE means that intervals defined by breaks are closed on the right and open on the left. 
      # We want the opposite, to include 0 on the left of the first interval.        
      breaks = c(0,1e-9,0.3,max_share_coop), 
      include.lowest = TRUE)

aoa_cells_toplot$CELL_SHARE_COOP_SIGNI_bin %>% table()

# This makes the bivariate bins
aoa_cells_toplot = 
  aoa_cells_toplot %>% 
  bi_class(CELL_COCOA_HA,
            CELL_SHARE_COOP_SIGNI_bin, 
            dim = 3, 
            style = "quantile", 
                  dig_lab = 9)

# This is just for display in the legend
breaks = 
  aoa_cells_toplot %>% 
  bi_class_breaks(CELL_COCOA_HA,
                  CELL_SHARE_COOP_SIGNI_bin, 
                  dim = 3, 
                  style = "quantile", 
                  dig_lab = 1) 
breaks$bi_y[1] = "0"
breaks$bi_y[2] = "]0,0.3]"
breaks$bi_y[3] = paste0("]0.3,",max_share_coop,"]")

map =
  ggplot() +
  geom_sf(data = aoa_cells_toplot, mapping = aes(fill = bi_class, col = bi_class), size = 1, shape = 22, # 22, 
          show.legend = FALSE) + # 
  geom_sf(data = departements, fill = "transparent", col = "darkgrey") +
  bi_scale_fill(pal = "GrPink2", dim = 3, na.value = "transparent") +
  bi_scale_color(pal = "GrPink2", dim = 3, na.value = "transparent") +
  labs(
    title = "Cooperative outlet and cocoa extent",
    subtitle = ""
  ) +
  bi_theme()

legend <- bi_legend(pal = "GrPink2",
                    dim = 3,
                    xlab = "Extent of cocoa farms",
                    ylab = "Share of cooperative outlet",
                    size = 6, 
                    breaks = breaks)



continous_aggregate_plot = 
  ggdraw() +
  draw_plot(map, 0, 0, 1, 1) +
  draw_plot(legend, x = 0.7, y = 0.2, width = 0.3, height = 0.3)

continous_aggregate_plot
```


Continuous productive
```{r}
# # This is mainly for plotting purposes - not even actually, it's useless. 
# table(cells$CELL_PRODUCTION_STATUS)
# 
# links = 
#   links %>% 
#   mutate(
#     # Commented out since I don't know what this should be used for - to weights ! (not summing to 1)
#     # across(.cols = contains("_PROBA_"), 
#     #        .fns = ~ .x  * CELL_COCOA_SHARE, 
#     #        .names = paste0("{.col}", "_COCOA")), 
#     CELL_SHARE_COOP_SIGNI_COCOA = CELL_SHARE_COOP_SIGNI * CELL_COCOA_SHARE
#   )
# 
# links %>% select(ends_with("_COCOA")) %>% names()

```


# Individual sourcing sheds
