---
title: "model"
author: "Valentin"
date: "`r Sys.Date()`"
output: 
  html_document:
      self_contained: false
---
# Set up and inputs
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(aws.s3)
aws.signature::use_credentials()
Sys.setenv("AWS_DEFAULT_REGION" = "eu-west-1")


library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)
library(here)
library(readstata13)
library(sjmisc)
library(terra) # put it after {raster} such that it superceeds homonym functions. 
library(exactextractr)
library(stars)
library(pals)
library(modelsummary) # necessary to load it after DescTools
library(ranger)
library(parsnip)

set.seed(8888)

## Functions
# Trase palettes etc. for plots
source(here("code", "theme_trase.R"))

# load in particular the function fn_trader_to_group_names, str_trans, ... 
source(here("code", "USEFUL_STUFF_supplyshedproj.R"))

MODEL_RESOLUTION_KM = 4

## Assets

# The cam at coop level is also needed for the exporting coop part (step 12)
# coopbsy = read.csv(file = here("temp_data/private_IC2B/IC2B_v2_coop_bs_year.csv")) 

cells = readRDS(here("temp_data", "prepared_main_dataset", paste0("cell_", MODEL_RESOLUTION_KM, "km.Rdata"))) 

links = readRDS(here("temp_data", "prepared_main_dataset", paste0("cell_links_", MODEL_RESOLUTION_KM, "km.Rdata")))

# Remove cells where there is no reachable coops, because many features are missing there. We are not interested in describing, learning from, or predicting in these cells. Post-estimation we will recollect them by re-reading the above. 
cells = 
  cells %>% 
  filter(!CELL_NO_POTENTIAL_LINK) 

links = 
  links %>% 
  filter(!CELL_NO_POTENTIAL_LINK) 


```

```{r}
# Pre-processing to ease manipulation/display

# cells %>% select(ends_with("COOP-CA")) %>% names()
cells = 
  cells %>% 
  mutate(SPLIT = if_else(CELL_VOLUME_OBSERVED, "Train/test set", "Predict set")) %>% 
  rename(CELL_PROP_COOP_STATUS_COOPCA = `CELL_PROP_COOP_STATUS_COOP-CA`, 
         CELL_PROP_1_NEAREST_COOP_STATUS_COOPCA = `CELL_PROP_1_NEAREST_COOP_STATUS_COOP-CA`, 
         CELL_PROP_5_NEAREST_COOP_STATUS_COOPCA = `CELL_PROP_5_NEAREST_COOP_STATUS_COOP-CA`)

# (this is different from CELL_ACTUAL_LINK bc actual links don't always have volume attached)



links = 
  links %>% 
  # mutate(SPLIT = if_else(CELL_ANY_ACTUAL_COOP_LINK, "Train/test set", "Predict set")) %>%
  mutate(SPLIT = if_else(CELL_ACTUAL_LINK & !CELL_ACTUAL_ONLYOTHER_LINK, "Train/test set", "Predict set")) %>%
  rename(COOP_STATUS_COOPCA = `COOP_STATUS_COOP-CA`,
         COOP_DISTRICT_SAN_PEDRO = `COOP_DISTRICT_SAN-PEDRO`,
         COOP_DISTRICT_GRAND_LAHOU = `COOP_DISTRICT_GRAND-LAHOU`,
         COOP_DISTRICT_YAKASSE_ATTOBROU = `COOP_DISTRICT_YAKASSE-ATTOBROU`,
         COOP_DISTRICT_ZOUAN_HOUNIEN = `COOP_DISTRICT_ZOUAN-HOUNIEN`,
         COOP_DISTRICT_KOUN_FAO = `COOP_DISTRICT_KOUN-FAO`,
         COOP_DISTRICT_GRAND_BASSAM = `COOP_DISTRICT_GRAND-BASSAM`, 
         COOP_DISTRICT_MBATTO = `COOP_DISTRICT_M'BATTO`)

```




# DESCRIPTIVES 
## Cells des. stats.

### Structure of the cell data
```{r}
# How many cells with actual links
# cells %>% 
#   select(!starts_with("CELL_PROP") & !starts_with("CELL_COUNT")) %>% 
#   datasummary_skim()

# export
(datasummary(N + Percent()  ~ 
              (`No potential link` = (CELL_NO_POTENTIAL_LINK==T)) + 
              (`Only virtual links` = (CELL_ONLY_VIRTUAL_LINK==T)) + 
              (`Actual links with cooperatives only` = (CELL_ACTUAL_ONLYCOOP_LINK==T)) + 
              (`Actual links with other buyers only` = (CELL_ACTUAL_ONLYOTHER_LINK==T)) + 
              (`Actual links with both` = (CELL_ACTUAL_BOTH_LINK==T)) + 
              1, 
              data = cells,
              fmt = 1,
              align = "ccccccc",
              output = here("outputs", paste0("cells_",MODEL_RESOLUTION_KM,"km_destat.png"))))

# ?tables::Heading

```
### Map of the cell data
```{r}
ggarrange(
  ggplot(plot_geocode) +
      geom_sf(aes(fill = VOL_UNTRACED), col = "white", linewidth = unit(0.002,"pt")) + 
      labs(#title = "INDIRECT SOURCING, 2022", 
           fill =  "") + 
      scale_size_identity() +
     
      scale_fill_gradient(na.value = trase_palettes[["no_data"]],
                          low = trase_palettes[["negative"]][1],
                          high = trase_palettes[["negative"]][9],
                          labels=unit_format(unit = "kMT", scale = 1e-3)) +

      theme_minimal() +
      scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'째W')) +
      scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'째N')) +
      theme(
        legend.key.width = unit(1.5, "cm"),
        legend.text = element_text(size = 12, face = "bold", family = "DM Sans", colour = trase_palettes[["legend"]]), # , face = "bold"
        ),
  
  ggplot(plot_geocode) +
    geom_sf(aes(fill = PCT_UNTRACED_GEOCODE), col = "white", linewidth = unit(0.002,"pt")) + 
    labs(#title = "DIRECT SOURCING FROM COOPERATIVES \nIN PROPORTION TO PRODUCTION, 2022", 
         fill =  "") + 
    scale_size_identity() +
    
    # scale_fill_gradientn(colours = c(rev(trase_palettes[["commodities"]]), 
    #                                    trase_palettes[["negative"]]),
    #                      na.value = trase_palettes[["no_data"]],
    #                      labels=unit_format(unit = "%")) + 
    scale_fill_gradient(na.value = trase_palettes[["no_data"]],
                        low = trase_palettes[["commodities"]][1],
                        high = trase_palettes[["commodities"]][9], # TraseGreen_TraseGray_TraseRed
                        labels=unit_format(unit = "%")) +
    
    theme_minimal() +
    scale_x_continuous(breaks = xlabs, labels = paste0(xlabs,'째W')) +
    scale_y_continuous(breaks = ylabs, labels = paste0(ylabs,'째N')) +
    theme(
      legend.key.width = unit(1.5, "cm"),
        legend.text = element_text(size = 12, face = "bold", family = "DM Sans", colour = trase_palettes[["legend"]]), # , face = "bold"
       ),
  
  ncol = 2, nrow = 1, common.legend = FALSE, legend = "bottom",
  widths = c(1, 1)
) 

```



### Cell data features

#### Target in the train/test set 
```{r}
names(cells)

(cells %>% 
  filter(CELL_VOLUME_OBSERVED) %>% 
  transmute(
    # `Cell ID` = CELL_ID,
    `Cooperative outlet share` = CELL_PROP_VOLUME_COOPS, 
    `Cocoa output from cells (kg)` = CELL_VOLUME_KG) %>% 
  datasummary_skim(output = here("outputs", paste0("cells_",MODEL_RESOLUTION_KM,"km_train_volumes.png"))))



```

#### Cell data balance tests
```{r}

cells_features_tobalance =
  cells %>% 
  select(SPLIT, 
         `# BS within 72km` = CELL_N_BS_WITHIN_DIST, 
         `Avg. distance of the 5 nearest BS (m)` = CELL_AVG_DISTANCE_METERS_5_NEAREST_COOPS, 
         `# registered licensed buyers in department` = CELL_AVG_N_LICBUY_IN_DPT, 
         `Cocoa extent (ha)` = CELL_COCOA_HA,
         `Settlements extent (ha)` = CELL_SETTLEMENT_HA,
         `Terrain Ruggedness Index (mm)` = CELL_TRI_MM,
         `Proportion of 5 nearest cooperatives certified` = CELL_PROP_5_NEAREST_COOP_CERTIFIED,
         `Proportion of 5 nearest cooperatives with SSIs` = CELL_PROP_5_NEAREST_COOP_HAS_SSI,
         `Proportion of 5 nearest cooperatives with CCP` = CELL_PROP_5_NEAREST_COOP_SSI_CARGILL,
         `Proportion of 5 nearest cooperatives being COOP-CA` = CELL_PROP_5_NEAREST_COOP_STATUS_SCOOPS,
         `Proportion of 5 nearest cooperatives being SCOOPS` = `CELL_PROP_5_NEAREST_COOP_STATUS_COOP-CA`,
         `Total # members of 5 nearest cooperatives` = CELL_COUNT_5_NEAREST_COOP_FARMERS,
         `Total # BS of 5 nearest cooperatives` = CELL_COUNT_5_NEAREST_COOP_N_KNOWN_BS,
         `Avg. # buying companies in 5 nearest cooperatives` = CELL_AVG_5_NEAREST_COOP_N_KNOWN_BUYERS,
         `Avg. TRI around 5 nearest cooperatives (mm)` = CELL_AVG_5_NEAREST_COOP_BS_10KM_TRI,
         `Avg. cocoa extent around 5 nearest cooperatives (ha)` = CELL_AVG_5_NEAREST_COOP_BS_10KM_COCOA_HA,
         `Avg. settlements extent around 5 nearest cooperatives` = CELL_AVG_5_NEAREST_COOP_BS_10KM_SETTLEMENT_HA
         ) 

(datasummary_balance(~SPLIT, 
                      data = cells_features_tobalance, 
                      stars = TRUE,
                      # title = "Summaries and balance tests on cell data sets to train/test and to predict the cell share of cooperative outlet", 
                      notes = "'BS' stands for cooperative buying stations.", 
                     output = here("outputs", "cells_balance.png")))        
  

```


## Links descriptive statistics

### Structure of the link data 
```{r}

```

### Features in the processed link data  
```{r}
links_features_tosum %>% 
  mutate(LINK_YEAR = as.character(LINK_YEAR)) %>% 
  select(starts_with("LINK_"), 
         all_of("COOP_DISTRICT_NAME", "COOP_STATUS"))

  
```



# FIRST STAGE 

## Data split
Resources on data split here: https://encord.com/blog/train-val-test-split/
```{r}
training_size <- 0.8

# Split the data
stg1_traintest =
  cells %>%
  filter(SPLIT == "Train/test set") 

stg1_topredict =
  cells %>%
  filter(SPLIT == "Predict set") 

stg1_training =
  stg1_traintest %>%
  slice_sample(prop = training_size) 

stg1_test =
  stg1_traintest %>%
  filter(!CELL_ID %in% stg1_training$CELL_ID) 

```

## Feature selection
Use Boruta here https://cran.r-project.org/web/packages/Boruta/Boruta.pdf
```{r}
names(cells)
anyNA(cells)

stg1_allfeatures = 
  cells %>% 
  select(
    ends_with("_HA"), CELL_TRI_MM, 
    CELL_N_BS_WITHIN_DIST, CELL_N_COOP_IN_DPT, CELL_AVG_N_LICBUY_IN_DPT,
    CELL_AVG_DISTANCE_METERS_5_NEAREST_COOPS, CELL_MIN_DISTANCE_METERS,
    starts_with("CELL_PROP_5_NEAREST"), 
    starts_with("CELL_AVG_5_NEAREST"), 
    starts_with("CELL_COUNT_5_NEAREST")) %>% 
  names() 
  

stg1_mformula_allfeatures = as.formula(paste0("CELL_PROP_VOLUME_COOPS ~ ", paste0(stg1_allfeatures, collapse = " + ")))




```


## Model fit 
```{r}

stg1_mfit = ranger(data = stg1_training, 
                   formula = stg1_mformula,
                   importance = 'permutation')

print(stg1_mfit)

```

## Evaluation 
```{r}
test_predictions <- predict(stg1_mfit, data=stg1_test)



```
## Predict 
```{r}
stg1_topredict$CELL_PRED_PROP_VOLUME_COOPS = predict(stg1_mfit, data=stg1_topredict)$predictions

stg1_topredict$CELL_PRED_PROP_VOLUME_COOPS %>% summary()

cells = 
  cells %>% 
  left_join(stg1_topredict %>% select(CELL_ID, CELL_PRED_PROP_VOLUME_COOPS), 
            by = "CELL_ID") %>% 
  # this left NAs in cells not in the predict set, i.e. in the train/test set
  mutate(CELL_PRED_PROP_VOLUME_COOPS = case_when(
    is.na(CELL_PRED_PROP_VOLUME_COOPS) ~ CELL_PROP_VOLUME_COOPS, 
    TRUE ~ CELL_PRED_PROP_VOLUME_COOPS
  ))

cells$CELL_PRED_PROP_VOLUME_COOPS %>% summary()

# at this stage, the NAs come from CELL_PROP_VOLUME_COOPS, in cells with no potential link at all 
stopifnot(cells %>% filter(is.na(CELL_PRED_PROP_VOLUME_COOPS)) %>% pull(CELL_NO_POTENTIAL_LINK) %>% all())






```


# SECOND STAGE 
 KEEP ONLY LINKS WITH COOPS AND REMOVE ACTUAL LINKS WITH OTHERS
 USE LINK_IS_ACTUAL_COOP ? 
 
## Apply sub-sampling
```{r}
links_ss = 
  links %>% 
  filter(!LINK_POSSIBLE_FALSENEG) %>% 
  filter(LINK_TO_KEEP_TO_US_VIRTUAL) # this is only TRUE currently. 

```


## Data split
Resources on data split here: https://encord.com/blog/train-val-test-split/
```{r}
training_size <- 0.8

# Split the data
stg2_traintest =
  links_ss %>%
  filter(SPLIT == "Train/test set") 

stg2_topredict =
  links_ss %>%
  filter(SPLIT == "Predict set") 

stg2_training =
  stg2_traintest %>%
  slice_sample(prop = training_size) 

stg2_test =
  stg2_traintest %>%
  filter(!LINK_ID %in% stg2_training$LINK_ID) 

```


## Feature selection
Use Boruta here https://cran.r-project.org/web/packages/Boruta/Boruta.pdf
```{r}
# names(links_ss)
anyNA(links_ss)

stg2_allfeatures = 
  links_ss %>% 
  select(
    ends_with("_HA"), CELL_TRI_MM, 
    CELL_N_BS_WITHIN_DIST, # CELL_N_COOP_IN_DPT, CELL_AVG_N_LICBUY_IN_DPT,
    # CELL_AVG_DISTANCE_METERS_5_NEAREST_COOPS, CELL_MIN_DISTANCE_METERS,
    LINK_DISTANCE_METERS,
    starts_with("COOP_FARMERS"), 
    COOP_N_KNOWN_BUYERS, COOP_N_KNOWN_BS,
    COOP_RFA, COOP_UTZ, COOP_FT,
    starts_with("COOP_CERTIFIED"), 
    COOP_HAS_SSI, 
    starts_with("COOP_SSI_"), 
    starts_with("COOP_DISTRICT_"), -COOP_DISTRICT_NAME,
    starts_with("COOP_STATUS_"), 
    starts_with("COOP_BS_10KM")
    ) %>% 
  names() 
  
grep("'", stg2_allfeatures, value = T)
stg2_mformula_allfeatures = as.formula(paste0("LINK_IS_ACTUAL_COOP ~ ", paste0(stg2_allfeatures, collapse = " + ")))




```




## Model fit 
```{r}

stg2_mfit = ranger(data = stg2_training, 
                   formula = stg2_mformula_allfeatures,
                   importance = 'permutation')

print(stg2_mfit)

```

## Evaluation 
```{r}
test_predictions <- predict(stg2_mfit, data=stg2_test)



```
## Predict 
```{r}
stg2_topredict$CELL_PRED_PROP_VOLUME_COOPS = predict(stg2_mfit, data=stg2_topredict)$predictions

stg2_topredict$CELL_PRED_PROP_VOLUME_COOPS %>% summary()

cells = 
  cells %>% 
  left_join(stg2_topredict %>% select(CELL_ID, CELL_PRED_PROP_VOLUME_COOPS), 
            by = "CELL_ID") %>% 
  # this left NAs in cells not in the predict set, i.e. in the train/test set
  mutate(CELL_PRED_PROP_VOLUME_COOPS = case_when(
    is.na(CELL_PRED_PROP_VOLUME_COOPS) ~ CELL_PROP_VOLUME_COOPS, 
    TRUE ~ CELL_PRED_PROP_VOLUME_COOPS
  ))

cells$CELL_PRED_PROP_VOLUME_COOPS %>% summary()

# at this stage, the NAs come from CELL_PROP_VOLUME_COOPS, in cells with no potential link at all 
stopifnot(cells %>% filter(is.na(CELL_PRED_PROP_VOLUME_COOPS)) %>% pull(CELL_NO_POTENTIAL_LINK) %>% all())






```