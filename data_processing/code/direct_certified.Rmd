---
title: "analyses_nitidae_private_IC2B"
author: "Valentin"
date: "`r Sys.Date()`"
output: html_document
---

# Set up and inputs
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(aws.s3)
aws.signature::use_credentials()
Sys.setenv("AWS_DEFAULT_REGION" = "eu-west-1")

library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)
library(here)
library(pals)

## Functions
# Trase palettes etc. for plots
source(here("code", "theme_trase.R"))

# load in particular the function fn_trader_to_group_names, str_trans, ... 
source(here("code", "USEFUL_STUFF_manually_copy_pasted.R"))

## Assets
kit_farm_production <- 
  read_delim(
    get_object("cote_divoire/cocoa/production_estimates/kit_farm_yield_observations.csv",
               bucket = "trase-storage",
               check_region = T),
    delim = ";"
  ) %>%
  select(cocoa_prod_total_kgs)

 # /!\/!\/!\ IMPORTANT *NOT* TO FILTER BY YEAR 
link <- 
  read.csv(
    file = here("temp_data/private_IC2B/IC2B_v2_link.csv")) %>% 
  # Variables needed in model
  # this is in trase standard format. width = 4 because the max number of coop_id is 5734 currently, so far from being larger than 9999. 
  mutate(SUPPLIER_ID = paste0("CI-COFFEE-COCOA-COOPERATIVE-", str_pad(COOP_ID, width=4, pad = "0"))) %>% 
  # Keep all variables in there, just rename some 
  rename(COOPACRONYM = SUPPLIER_ABRVNAME, 
         COOPNAME = SUPPLIER_FULLNAME)
# Names of top actors
disclosing_trader_names <- link$TRADER_NAME %>% unique() %>% sort()


# The cam at coop level is also needed for the exporting coop part (step 12)
coopbsy <- 
  read.csv(
    file = here("temp_data/private_IC2B/IC2B_v2_coop_bs_year.csv")) %>% 
    distinct(COOP_ID, .keep_all = TRUE) %>%
    mutate(SUPPLIER_ID = paste0("CI-COFFEE-COCOA-COOPERATIVE-", str_pad(COOP_ID, width=4, pad = "0")))


# output summarized **AND POST TRASE FORMATTING*
outsum22 <- read_delim(file = here("temp_data/SEIPCS_adapted_to_IC2B_V2/SEI_PCS_COTE_DIVOIRE_COCOA_2022.csv"), 
                       delim = ",",
                       col_types = cols(HS6 = col_character(),
                                        PRODUCT_B_CODE = col_character()))

# all volumes exported per exporter, per destination country, per cocoa seller  
# it is quite different because it has not been standardized for Trase. 
out22 <- readRDS(here("temp_data/SEIPCS_adapted_to_IC2B_V2/volume_val_exporteroriginal_country_producer_2022.rds")) 
out22 <- 
  out22 %>%
  rename(GEOCODE = GEOCODE_PROVIDER) %>%
  filter(! GEOCODE == "UNKNOWN") %>%
  select(-GEOCODE_COCOA)


# ADDING USEFUL VARIABLES --------------------
link = 
  link %>% 
  mutate(CERTIFICATION_DISCLOSURE = DISCLOSURE_SOURCE %in% c("RAINFOREST ALLIANCE", "FAIRTRADE"), 
         # this removes NAs because grepl("RA", NA) -> FALSE
         CERTIFIED = grepl("RAINFOREST ALLIANCE|UTZ|FAIRTRADE", CERTIFICATIONS), #|FAIR FOR LIFE|BIOLOGIQUE
         RFA = grepl("RAINFOREST ALLIANCE", CERTIFICATIONS),
         UTZ = grepl("UTZ", CERTIFICATIONS),
         FT = grepl("FAIRTRADE", CERTIFICATIONS),
         ONLY_RFA = RFA & !UTZ & !FT,
         ONLY_UTZ = !RFA & UTZ & !FT,
         ONLY_FT  = !RFA & !UTZ & FT,
         RFA_AND_UTZ = RFA & UTZ & !FT,
         RFA_AND_FT  = RFA & !UTZ & FT,
         UTZ_AND_FT  = !RFA & UTZ & FT,
         RFA_AND_UTZ_AND_FT = RFA & UTZ & FT,
         CERTIFICATION_DETAIL = case_when(
           ONLY_RFA ~ "RFA",
           ONLY_UTZ ~ "UTZ",
           ONLY_FT ~ "FT",
           RFA_AND_UTZ ~ "RFA & UTZ",
           RFA_AND_FT ~ "RFA & FT",
           UTZ_AND_FT ~ "UTZ & FT",
           RFA_AND_UTZ_AND_FT ~ "RFA & UTZ & FT",
           TRUE ~ ""
         ),
         HAS_SSI = grepl("[(]", CERTIFICATIONS), # see fn_standard_certification_names in private_IC2B.R
         CERTIFIED_OR_SSI = CERTIFICATIONS != ""
         )

coopbsy = 
  coopbsy %>% 
  mutate(CERTIFICATION_DISCLOSURE = DISCLOSURE_SOURCES %in% c("RAINFOREST ALLIANCE", "FAIRTRADE"), 
         # this removes NAs because grepl("RA", NA) -> FALSE
         CERTIFIED = grepl("RAINFOREST ALLIANCE|UTZ|FAIRTRADE", CERTIFICATIONS), #|FAIR FOR LIFE|BIOLOGIQUE
         RFA = grepl("RAINFOREST ALLIANCE", CERTIFICATIONS),
         UTZ = grepl("UTZ", CERTIFICATIONS),
         FT = grepl("FAIRTRADE", CERTIFICATIONS),
         ONLY_RFA = RFA & !UTZ & !FT,
         ONLY_UTZ = !RFA & UTZ & !FT,
         ONLY_FT  = !RFA & !UTZ & FT,
         RFA_AND_UTZ = RFA & UTZ & !FT,
         RFA_AND_FT  = RFA & !UTZ & FT,
         UTZ_AND_FT  = !RFA & UTZ & FT,
         RFA_AND_UTZ_AND_FT = RFA & UTZ & FT,
         CERTIFICATION_DETAIL = case_when(
           ONLY_RFA ~ "RFA",
           ONLY_UTZ ~ "UTZ",
           ONLY_FT ~ "FT",
           RFA_AND_UTZ ~ "RFA & UTZ",
           RFA_AND_FT ~ "RFA & FT",
           UTZ_AND_FT ~ "UTZ & FT",
           RFA_AND_UTZ_AND_FT ~ "RFA & UTZ & FT",
           TRUE ~ ""
         ),
         HAS_SSI = grepl("[(]", CERTIFICATIONS), # see fn_standard_certification_names in private_IC2B.R
         CERTIFIED_OR_SSI = CERTIFICATIONS != ""
         )

out22 <- 
  out22 %>% 
  mutate(IS_EXPCOOP = grepl(pattern = "[(]COOPERATIVE[)]", EXPORTER_GROUP_CLEAN),
         IS_DEST_EU = fn_is_in_eu(COUNTRY_OF_DESTINATION),

         # this removes NAs because grepl("RA", NA) -> FALSE
         CERTIFIED = grepl("RAINFOREST ALLIANCE|UTZ|FAIRTRADE", CERTIFICATIONS), #|FAIR FOR LIFE|BIOLOGIQUE
         RFA = grepl("RAINFOREST ALLIANCE", CERTIFICATIONS),
         UTZ = grepl("UTZ", CERTIFICATIONS),
         FT = grepl("FAIRTRADE", CERTIFICATIONS),
         ONLY_RFA = RFA & !UTZ & !FT,
         ONLY_UTZ = !RFA & UTZ & !FT,
         ONLY_FT  = !RFA & !UTZ & FT,
         RFA_AND_UTZ = RFA & UTZ & !FT,
         RFA_AND_FT  = RFA & !UTZ & FT,
         UTZ_AND_FT  = !RFA & UTZ & FT,
         RFA_AND_UTZ_AND_FT = RFA & UTZ & FT,
         CERTIFICATION_DETAIL = case_when(
           ONLY_RFA ~ "RFA",
           ONLY_UTZ ~ "UTZ",
           ONLY_FT ~ "FT",
           RFA_AND_UTZ ~ "RFA & UTZ",
           RFA_AND_FT ~ "RFA & FT",
           UTZ_AND_FT ~ "UTZ & FT",
           RFA_AND_UTZ_AND_FT ~ "RFA & UTZ & FT",
           TRUE ~ ""
         ),
         HAS_SSI = grepl("[(]", CERTIFICATIONS), # see fn_standard_certification_names in private_IC2B.R
         # this has NAs however
         CERTIFIED_OR_SSI = CERTIFICATIONS != "")

outsum22 <- 
  outsum22 %>% 
  mutate(IS_EXPCOOP = grepl(pattern = "[(]COOPERATIVE[)]", EXPORTER_GROUP_CLEAN),
         IS_INDIRECT = (LVL4_NAME_PROD == "INDIRECT SOURCING"),
         IS_UNKNOWN  = (LVL4_NAME_PROD == "UNKNOWN"),
         IS_DIRECT = !IS_INDIRECT & !IS_UNKNOWN, 
         IS_UNTRACED = !IS_DIRECT,
         IS_DEST_EU = fn_is_in_eu(COUNTRY_OF_DESTINATION), 
         IS_BEANS = (PRODUCT == "COCOA BEANS"),
         IS_PASTE = (PRODUCT == "COCOA PASTE"),
         IS_BUTTER = (PRODUCT == "COCOA BUTTER"),
         IS_POWDER = (PRODUCT == "COCOA POWDER"),
         
         # this removes NAs because grepl("RA", NA) -> FALSE
         CERTIFIED = grepl("RAINFOREST ALLIANCE|UTZ|FAIRTRADE", CERTIFICATIONS), #|FAIR FOR LIFE|BIOLOGIQUE
         RFA = grepl("RAINFOREST ALLIANCE", CERTIFICATIONS),
         UTZ = grepl("UTZ", CERTIFICATIONS),
         FT = grepl("FAIRTRADE", CERTIFICATIONS),
         ONLY_RFA = RFA & !UTZ & !FT,
         ONLY_UTZ = !RFA & UTZ & !FT,
         ONLY_FT  = !RFA & !UTZ & FT,
         RFA_AND_UTZ = RFA & UTZ & !FT,
         RFA_AND_FT  = RFA & !UTZ & FT,
         UTZ_AND_FT  = !RFA & UTZ & FT,
         RFA_AND_UTZ_AND_FT = RFA & UTZ & FT,
         CERTIFICATION_DETAIL = case_when(
           ONLY_RFA ~ "RFA",
           ONLY_UTZ ~ "UTZ",
           ONLY_FT ~ "FT",
           RFA_AND_UTZ ~ "RFA & UTZ",
           RFA_AND_FT ~ "RFA & FT",
           UTZ_AND_FT ~ "UTZ & FT",
           RFA_AND_UTZ_AND_FT ~ "RFA & UTZ & FT",
           TRUE ~ ""
         ),
         HAS_SSI = grepl("[(]", CERTIFICATIONS), # see fn_standard_certification_names in private_IC2B.R
         # this has NAs however
         CERTIFIED_OR_SSI = CERTIFICATIONS != "")


flow_sum_22 <- 
  outsum22 %>% 
    summarise(.by = YEAR, 
              VOLUME_BEAN_EQUIVALENT_THOUSAND_TONNES = sum(VOLUME_BEAN_EQUIVALENT) / 1e6,
              CIF_MILLION_USD = sum(CIF_USD) / 1e6, 
              VOLUME_BEQ_BEANS_THOUSAND_TONNES = sum(VOLUME_BEAN_EQUIVALENT*IS_BEANS) / 1e6,
              VOLUME_BEQ_PASTE_THOUSAND_TONNES = sum(VOLUME_BEAN_EQUIVALENT*IS_PASTE) / 1e6,
              VOLUME_BEQ_BUTTER_THOUSAND_TONNES = sum(VOLUME_BEAN_EQUIVALENT*IS_BUTTER) / 1e6,
              VOLUME_BEQ_POWDER_THOUSAND_TONNES = sum(VOLUME_BEAN_EQUIVALENT*IS_POWDER) / 1e6,
              
              VOL_DIRECT_THOUSAND_TONNES =   sum(VOLUME_BEAN_EQUIVALENT*IS_DIRECT) / 1e6, 
              VOL_INDIRECT_THOUSAND_TONNES = sum(VOLUME_BEAN_EQUIVALENT*IS_INDIRECT) / 1e6, 
              VOL_UNKNOWN_THOUSAND_TONNES =  sum(VOLUME_BEAN_EQUIVALENT*IS_UNKNOWN) / 1e6, 
              VOL_UNTRACED_THOUSAND_TONNES =  sum(VOLUME_BEAN_EQUIVALENT*IS_UNTRACED) / 1e6,
              
              PCT_DIRECT = 100 * VOL_DIRECT_THOUSAND_TONNES / VOLUME_BEAN_EQUIVALENT_THOUSAND_TONNES, 
              PCT_INDIRECT = 100 * VOL_INDIRECT_THOUSAND_TONNES / VOLUME_BEAN_EQUIVALENT_THOUSAND_TONNES,
              PCT_UNKNOWN = 100 * VOL_UNKNOWN_THOUSAND_TONNES / VOLUME_BEAN_EQUIVALENT_THOUSAND_TONNES,
              PCT_UNTRACED = 100 * VOL_UNTRACED_THOUSAND_TONNES / VOLUME_BEAN_EQUIVALENT_THOUSAND_TONNES, 
              
              VOLUME_BEQ_EU_THOUSAND_TONNES = sum(VOLUME_BEAN_EQUIVALENT*IS_DEST_EU)/1e6,
              PCT_EU = 100 * VOLUME_BEQ_EU_THOUSAND_TONNES / VOLUME_BEAN_EQUIVALENT_THOUSAND_TONNES 

)

```


# CERTIFIED VOLUMES IN TRASE DIRECT SOURCING 

## Breaking down by destination
```{r}
direct_ktonnes_2022 <-
  flow_sum_22 %>% filter(YEAR == 2022) %>% pull(VOL_DIRECT_THOUSAND_TONNES)

out22 %>% filter(is.na(CERTIFICATIONS)) %>% nrow() 
out22$CERTIFICATIONS %>% unique()
out22$CERTIFICATION_DETAIL %>% unique()

# This is only direct supply flows
by_eu_certdet0 <-
  out22 %>% 
  unnest(cols = c(COOP_SOURCED_DIRECT_VOLUME_BEQ_distribution, 
                  COOP_SOURCED_DIRECT_VAL_distribution)) %>%
  # convert here in KTONNES
  mutate(COOP_SOURCED_DIRECT_VOLUME_BEQ = 1e-6 * COOP_SOURCED_DIRECT_VOLUME_BEQ) %>% 
  #sum over the different traders, destinations and HS codes to obtain 1000 values per geocode
  summarise(.by = c(IS_DEST_EU, CERTIFICATION_DETAIL, NUM_COOP_SOURCED_DIRECT_VOLUME_BEQ),
            COOP_SOURCED_DIRECT_VAL = sum(COOP_SOURCED_DIRECT_VAL),
            COOP_SOURCED_DIRECT_VOLUME_BEQ = sum(COOP_SOURCED_DIRECT_VOLUME_BEQ), 
            PRICE_BEQ = COOP_SOURCED_DIRECT_VAL / COOP_SOURCED_DIRECT_VOLUME_BEQ) %>% 
  # this averages across monte carlo simulations
  summarise(.by = c(IS_DEST_EU, CERTIFICATION_DETAIL),
            DIRECT_KTONNES_BEAN_EQ = mean(COOP_SOURCED_DIRECT_VOLUME_BEQ),
            CI95 = list(c(DIRECT_KTONNES_BEAN_EQ - 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ))), 
                                 DIRECT_KTONNES_BEAN_EQ + 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ)))
                                 ))
            ) %>% 
  arrange(IS_DEST_EU, CERTIFICATION_DETAIL) 

by_certdet0 <-
  out22 %>% 
  unnest(cols = c(COOP_SOURCED_DIRECT_VOLUME_BEQ_distribution, 
                  COOP_SOURCED_DIRECT_VAL_distribution)) %>%
  # convert here in KTONNES
  mutate(COOP_SOURCED_DIRECT_VOLUME_BEQ = 1e-6 * COOP_SOURCED_DIRECT_VOLUME_BEQ) %>% 
  #sum over the different traders, destinations and HS codes to obtain 1000 values per geocode
  summarise(.by = c(CERTIFICATION_DETAIL, NUM_COOP_SOURCED_DIRECT_VOLUME_BEQ),
            COOP_SOURCED_DIRECT_VOLUME_BEQ = sum(COOP_SOURCED_DIRECT_VOLUME_BEQ)#, 
            ) %>% 
  # this averages across monte carlo simulations
  summarise(.by = c(CERTIFICATION_DETAIL),
            DIRECT_KTONNES_BEAN_EQ = mean(COOP_SOURCED_DIRECT_VOLUME_BEQ),
            CI95 = list(c(DIRECT_KTONNES_BEAN_EQ - 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ))), 
                                 DIRECT_KTONNES_BEAN_EQ + 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ)))
                                 ))
            ) %>% 
  arrange(CERTIFICATION_DETAIL) 

by_eu_certified0 <- 
  out22 %>% 
  unnest(cols = c(COOP_SOURCED_DIRECT_VOLUME_BEQ_distribution, 
                  COOP_SOURCED_DIRECT_VAL_distribution)) %>%
  # convert here in KTONNES
  mutate(COOP_SOURCED_DIRECT_VOLUME_BEQ = 1e-6 * COOP_SOURCED_DIRECT_VOLUME_BEQ) %>% 
  #sum over the different traders, destinations and HS codes to obtain 1000 values per geocode
  summarise(.by = c(IS_DEST_EU, CERTIFIED, NUM_COOP_SOURCED_DIRECT_VOLUME_BEQ),
            COOP_SOURCED_DIRECT_VAL = sum(COOP_SOURCED_DIRECT_VAL),
            COOP_SOURCED_DIRECT_VOLUME_BEQ = sum(COOP_SOURCED_DIRECT_VOLUME_BEQ), 
            PRICE_BEQ = COOP_SOURCED_DIRECT_VAL / COOP_SOURCED_DIRECT_VOLUME_BEQ) %>% 
  # this averages across monte carlo simulations
  summarise(.by = c(IS_DEST_EU, CERTIFIED),
            DIRECT_KTONNES_BEAN_EQ = mean(COOP_SOURCED_DIRECT_VOLUME_BEQ),
            CI95 = list(c(DIRECT_KTONNES_BEAN_EQ - 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ))), 
                                 DIRECT_KTONNES_BEAN_EQ + 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ)))
                                 ))
            ) %>% 
  arrange(IS_DEST_EU, CERTIFIED) 
  
by_certified0 <-
  out22 %>% 
  unnest(cols = c(COOP_SOURCED_DIRECT_VOLUME_BEQ_distribution, 
                  COOP_SOURCED_DIRECT_VAL_distribution)) %>%
  # convert here in KTONNES
  mutate(COOP_SOURCED_DIRECT_VOLUME_BEQ = 1e-6 * COOP_SOURCED_DIRECT_VOLUME_BEQ) %>%
  #sum over certification status to obtain 1000 values per geocode
  summarise(.by = c(CERTIFIED, NUM_COOP_SOURCED_DIRECT_VOLUME_BEQ),
            COOP_SOURCED_DIRECT_VOLUME_BEQ = sum(COOP_SOURCED_DIRECT_VOLUME_BEQ)) %>% 
  # this averages across monte carlo simulations
  summarise(.by = c(CERTIFIED),
            DIRECT_KTONNES_BEAN_EQ = mean(COOP_SOURCED_DIRECT_VOLUME_BEQ),
            CI95 = list(c(DIRECT_KTONNES_BEAN_EQ - 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ))), 
                                 DIRECT_KTONNES_BEAN_EQ + 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ)))
                                 ))
            ) %>% 
  arrange(CERTIFIED)   
   

df <- by_certdet0
rm(df, toret)

make_share <- function(df){
  toret <- 
  df %>% 
  mutate(YEAR = 2022) %>% 
  inner_join(flow_sum_22 %>% select(YEAR, 
                                    VOL_DIRECT_THOUSAND_TONNES), by = "YEAR") %>% 
  mutate(TOTAL_DIRECT_KTONNES_BEAN_EQ = VOL_DIRECT_THOUSAND_TONNES,
         SHARE_OF_DIRECT = DIRECT_KTONNES_BEAN_EQ / TOTAL_DIRECT_KTONNES_BEAN_EQ) %>% 
  select(-VOL_DIRECT_THOUSAND_TONNES)
  
# Checks: 
  if(round(sum(toret$SHARE_OF_DIRECT),10) != 1){stop("problem")}
  if(round(sum(toret$DIRECT_KTONNES_BEAN_EQ), 4) != round(direct_ktonnes_2022,4)){ stop() }
  return(toret)
}

by_eu_certdet <- make_share(by_eu_certdet0)
by_certdet <- make_share(by_certdet0)
by_eu_certified <- make_share(by_eu_certified0)
by_certified <- make_share(by_certified0)

by_eu_certdet
by_certdet
by_eu_certified
by_certified


by_certdet$DIRECT_KTONNES_BEAN_EQ %>% sum() == sum(by_certified$DIRECT_KTONNES_BEAN_EQ)

direct_certified_ktonnes <-   
  by_eu_certified %>% filter(CERTIFIED) %>% pull(DIRECT_KTONNES_BEAN_EQ) %>% sum() 

direct_certified_noneu_ktonnes <- 
  by_eu_certified %>% filter(!IS_DEST_EU & CERTIFIED) %>% pull(DIRECT_KTONNES_BEAN_EQ) 
# corresponding pct 
pct_direct_being_certified_noneu <- 
  by_eu_certified %>% filter(!IS_DEST_EU & CERTIFIED) %>% pull(SHARE_OF_DIRECT) * 100

direct_certified_eu_ktonnes <- 
  by_eu_certified %>% filter(IS_DEST_EU & CERTIFIED) %>% pull(DIRECT_KTONNES_BEAN_EQ) 
pct_direct_being_certified_eu <- 
  by_eu_certified %>% filter(IS_DEST_EU & CERTIFIED) %>% pull(SHARE_OF_DIRECT) * 100
  

# The answer to Nitidae's question of how much directly sourced cocoa is certified? 
pct_direct_certified <- 
  100 * direct_certified_ktonnes / direct_ktonnes_2022
pct_direct_certified %>% round(0)

# with CI 
by_certified1 <-
  out22 %>% 
  unnest(cols = c(COOP_SOURCED_DIRECT_VOLUME_BEQ_distribution)) %>%
  # convert here in KTONNES
  mutate(COOP_SOURCED_DIRECT_VOLUME_BEQ = 1e-6 * COOP_SOURCED_DIRECT_VOLUME_BEQ) %>%
  #sum over certification status to obtain 1000 values per geocode
  group_by(NUM_COOP_SOURCED_DIRECT_VOLUME_BEQ) %>% 
  mutate(TOTAL_DIRECT_KTONNES_BEAN_EQ = sum(COOP_SOURCED_DIRECT_VOLUME_BEQ)) %>% 
  
  group_by(CERTIFIED, NUM_COOP_SOURCED_DIRECT_VOLUME_BEQ) %>% 
  mutate(
    COOP_SOURCED_DIRECT_VOLUME_BEQ = sum(COOP_SOURCED_DIRECT_VOLUME_BEQ),
    SHARE_OF_DIRECT = COOP_SOURCED_DIRECT_VOLUME_BEQ / TOTAL_DIRECT_KTONNES_BEAN_EQ
    ) %>% 
  ungroup() %>% 
  # this averages across monte carlo simulations
  summarise(.by = c(CERTIFIED),
            DIRECT_KTONNES_BEAN_EQ = mean(COOP_SOURCED_DIRECT_VOLUME_BEQ),
            CI95_VOL = list(c(DIRECT_KTONNES_BEAN_EQ - 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ))), 
                                 DIRECT_KTONNES_BEAN_EQ + 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ)))
                                 )), 
            SHARE_OF_DIRECT = mean(SHARE_OF_DIRECT),
            ELMT_CI95_SHARE = qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ))),
            CI95_SHARE = list(c(SHARE_OF_DIRECT - 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ))), 
                                 SHARE_OF_DIRECT + 
                                   qt(0.95/2+0.5, length(COOP_SOURCED_DIRECT_VOLUME_BEQ)-1) *
                                   (sd(COOP_SOURCED_DIRECT_VOLUME_BEQ)/sqrt(length(COOP_SOURCED_DIRECT_VOLUME_BEQ)))
                                 ))
            ) %>% 
  arrange(CERTIFIED)   

# Comparing with certification bodies figures: 

to_share <- 
  by_eu_certdet %>% 
    select(YEAR, TOTAL_DIRECT_KTONNES_BEAN_EQ, CERTIFICATION_DETAIL, IS_DEST_EU, DIRECT_KTONNES_BEAN_EQ, SHARE_OF_DIRECT)

write.csv(to_share, 
          here("temp_data", "direct_certified_breakdown_2022.csv"))
```


# CERTIFIED VOLUMES DISCLOSED BY BODIES
```{r}

# Tonnes certified produced:
discl_certif <- 
  tibble(
    SCHEME = c("RFA", "UTZ", "FT"),
    CERTIFIED_PRODUCED_KTONNES = c("RFA" = 162.270, "UTZ" = 485.797, "FT" = 512.033),
    CERTIFIED_SOLD_KTONNES = c("RFA" = 126.279, "UTZ" = 442.515, 512.0330), # for FT this is NA so replace by production. 
    # correction factors to remove the amount of RFA that is also UTZ or FT, and remove the amount of UTZ that is FT. 
    DOUBLE_CERTIF_CORRECTION = c("RFA" = 1-0.12-0.11, "UTZ" = 1-0.13, "FT" = 1),
  ) %>% 
  mutate(CORRECTED_CERTIFIED_PRODUCED_KTONNES = CERTIFIED_PRODUCED_KTONNES*DOUBLE_CERTIF_CORRECTION,
         CORRECTED_CERTIFIED_SOLD_KTONNES = CERTIFIED_SOLD_KTONNES*DOUBLE_CERTIF_CORRECTION
         )
           
# Produce figures that mimic the corrections we applied above: (approximative since it does not correct exactly for triple certif)
discl_certif$SIMILARLY_CORRECTED_SEIPCS_DIRECT_KTONNES <- 
  c("RFA" = 
    by_certdet %>% 
    # RFA completely corrected
    filter(CERTIFICATION_DETAIL=="RFA") %>%  
    pull(DIRECT_KTONNES_BEAN_EQ) %>% 
    sum(),
    "UTZ" = 
    by_certdet %>% 
    # UTZ corrected from FT but including RFA
    filter(CERTIFICATION_DETAIL %in% c("UTZ", "RFA & UTZ")) %>%  
    pull(DIRECT_KTONNES_BEAN_EQ) %>% 
    sum(),
    "FT" =
    by_certdet %>% 
    # any FT
    filter(grepl("FT", CERTIFICATION_DETAIL)) %>%  
    pull(DIRECT_KTONNES_BEAN_EQ) %>% 
    sum()
  )

# this is the inherently corrected sei-pcs value, only available aggregated
direct_certified_ktonnes
# while this is the one rebuilding and correcting overlapping volumes 
sum(discl_certif$SIMILARLY_CORRECTED_SEIPCS_DIRECT_KTONNES)

sum(discl_certif$CORRECTED_CERTIFIED_PRODUCED_KTONNES) - sum(discl_certif$SIMILARLY_CORRECTED_SEIPCS_DIRECT_KTONNES)
sum(discl_certif$CORRECTED_CERTIFIED_SOLD_KTONNES) - sum(discl_certif$SIMILARLY_CORRECTED_SEIPCS_DIRECT_KTONNES)


discl_certif$RFA_CORRECTED_CERTIFIED_PRODUCED_TONNES %>% sum() *1e-3
discl_certif

```

# CERTIFIED VOLUMES IN IC2B 
Here, we count the number of farmers disclosed to be certified in 2019 (when we have that number for RFA and FT). 
```{r}
link19_cert <-
  link %>% 
  filter(YEAR == 2019 & DISCLOSURE_SOURCE %in% c("RAINFOREST ALLIANCE", "FAIRTRADE", "UTZ"))

cert19 <- 
  link19_cert %>% 
  summarise(.by = DISCLOSURE_SOURCE, 
            NB_FARMERS = sum(NUM_FARMERS, na.rm = T)) %>% 
  mutate(EST_PRODUCTION_KTONNES = NB_FARMERS * 1e-6 * mean(kit_farm_production$cocoa_prod_total_kgs))

```



In the `r round(direct_ktonnes_2022, 0)` thousand tonnes directly sourced in Côte d'Ivoire in 2022, we estimate that certified cooperatives supply `r round(direct_certified_ktonnes, 0)` thousand tonnes, i.e. `r round(pct_direct_certified, 1)`%. 

The EU imports `r round(direct_certified_eu_ktonnes,0)` thousand tonnes of cocoa directly sourced from a certified cooperative, while the rest of the worlds imports `r round(direct_certified_noneu_ktonnes,0)` thousand tonnes. 
Hence, the EU imports `r round(100 * direct_certified_eu_ktonnes / direct_certified_ktonnes, 1)`% of the cocoa directly sourced from certified cooperatives in Côte d'Ivoire. 



# Private IC2B descriptives 
```{r}
camcy22 <- 
  coopbsy %>% 
  filter(YEAR==2022)

camlink22 <- 
  link %>% 
  filter(YEAR==2022) 

# distinct coops identified
nb_dst_coops_civ22 <- 
  nrow(camcy22)

# distinct disclosing companies 
# link$DISCLOSURE_SOURCE %>% unique() 


# coop-company links identified
nb_coop_comp_links_civ22 <- 
  camlink22 %>% 
  filter(!is.na(DISCLOSURE_SOURCE) & !DISCLOSURE_SOURCE %in% c("RAINFOREST ALLIANCE", "FAIRTRADE")) %>% 
  nrow()


# distinct coops linked with a company
nb_dst_linked_coops_civ22 <-
  camlink22 %>% 
  filter(!is.na(DISCLOSURE_SOURCE) & !DISCLOSURE_SOURCE %in% c("RAINFOREST ALLIANCE", "FAIRTRADE")) %>% 
  select(COOP_ID) %>% 
  unique() %>% 
  nrow() 

# Coops with info on number of farmers
nb_dst_coops_farmers_civ22 <-
  camlink22 %>% 
  filter(!all(is.na(DISCL_NUMBER_FARMERS)), .by = COOP_ID) %>% 
  pull(COOP_ID) %>% 
  unique() %>% 
  length() 
# NOT identical to: 
camcy22 %>% 
  filter(!is.na(TOTAL_FARMERS)) %>% 
  nrow()
# because this includes cooperatives for which there is info only from RFA or FT now. 

# Number of coops with at least one SSI program disclosed
nb_dst_coops_SSI_civ22 <-
camlink22 %>% 
  filter(HAS_SSI) %>% 
  pull(COOP_ID) %>% 
  unique() %>% 
  length() 

# distinct coops disclosed by FAIRTRADE
nb_dst_coops_fairtrade <-
  camlink22 %>% 
  filter(DISCLOSURE_SOURCE == "FAIRTRADE") %>% 
  select(COOP_ID) %>% 
  unique() %>% 
  nrow() 


# Store everything in a table 
colna <- c("Distinct cooperatives", "Coop-company links", "Coops linked with a company", "Coops with some farmer info", "Coops with a SSI")
rowna <- c("In 2022") 

compar_tbl <- 
  data.frame("A" = c(nb_dst_coops_civ22), 
             "B" = c(nb_coop_comp_links_civ22),
             "C" = c(nb_dst_linked_coops_civ22),
             "D" = c(nb_dst_coops_farmers_civ22),
             "E" = c(nb_dst_coops_SSI_civ22),
             row.names = rowna)
names(compar_tbl) <- colna
# nb_dst_coops_fairtrade
compar_tbl

```
# Certification descriptives
```{r}
# The problem is that RFA does not disclose the number of certified farmers per coop (this is only available in CAM v3)
# And FT does disclose it, but only for 2022 (supposedly). 

# Total number of farmers 

# Total minimum number of farmers supplying a coop in 2022 and 2023
coopbsy %>% filter(YEAR == 2019) %>% pull(TOTAL_FARMERS) %>% sum(na.rm = TRUE)
coopbsy %>% filter(YEAR == 2019) %>% pull(TOTAL_FARMERS) %>% summary()

coopbsy %>% filter(YEAR == 2020) %>% pull(TOTAL_FARMERS) %>% sum(na.rm = TRUE)
coopbsy %>% filter(YEAR == 2020) %>% pull(TOTAL_FARMERS) %>% summary()

coopbsy %>% filter(YEAR == 2021) %>% pull(TOTAL_FARMERS) %>% sum(na.rm = TRUE)
coopbsy %>% filter(YEAR == 2021) %>% pull(TOTAL_FARMERS) %>% summary()

coopbsy %>% filter(YEAR == 2022) %>% pull(TOTAL_FARMERS) %>% sum(na.rm = TRUE)
coopbsy %>% filter(YEAR == 2022) %>% pull(TOTAL_FARMERS) %>% summary()

coopbsy %>% filter(YEAR == 2023) %>% pull(TOTAL_FARMERS) %>% sum(na.rm = TRUE)
coopbsy %>% filter(YEAR == 2023) %>% pull(TOTAL_FARMERS) %>% summary()

camcy22 %>% filter(is.na(TOTAL_FARMERS)) %>% View()

link %>% filter(YEAR == 2022) %>% pull(NUM_FARMERS_EXTRAPOLATED) %>% sum(na.rm = TRUE)
link %>% filter(YEAR == 2022) %>% pull(NUM_FARMERS_EXTRAPOLATED) %>% summary()

link %>% filter(YEAR == 2023) %>% pull(NUM_FARMERS_EXTRAPOLATED) %>% sum(na.rm = TRUE)
link %>% filter(YEAR == 2023) %>% pull(NUM_FARMERS_EXTRAPOLATED) %>% summary()

link %>% filter(YEAR == 2022) %>% pull(NUM_FARMERS) %>% sum(na.rm = TRUE)
link %>% filter(YEAR == 2022) %>% pull(NUM_FARMERS) %>% summary()

link %>% filter(YEAR == 2023) %>% pull(NUM_FARMERS) %>% sum(na.rm = TRUE)
link %>% filter(YEAR == 2023) %>% pull(NUM_FARMERS) %>% summary()

# link %>% filter(YEAR == 2022) %>% distinct(COOP_ID, .keep_all = T) %>% pull(TOTAL_FARMERS) %>% sum(na.rm = TRUE)

# Number of farmers with at least one certification 
## At least RFA
camlink22 %>% filter(DISCLOSURE_SOURCE == "RAINFOREST ALLIANCE") %>% pull(NUM_FARMERS) %>% sum(na.rm = T)
camcy22$TOTAL_FARMERS_RFA %>% sum(na.rm = T)
# Why such a difference? Because RFA does not disclose its number of farmers. We have it in TOTAL_FARMERS_RFA thanks to the CAM

# Recall that RFA includes UTZ here. But 943800 FARMERS is still too much compared to ~650 TONNES of RA&UTZ their official number

# HOWEVER, PB THAT IN 2021 IT IS NOT THE SAME AT ALL, 


coopbsy %>% filter(YEAR == 2021) %>% pull(TOTAL_FARMERS_RFA) %>% sum(na.rm = T)

## At least FT
camlink22 %>% filter(DISCLOSURE_SOURCE == "FAIRTRADE") %>% pull(NUM_FARMERS) %>% sum(na.rm = T)
camcy22$TOTAL_FARMERS_FT %>% sum(na.rm = T)

# They all supply a cooperative, i.e. the direct supply chain.  

# Number of certified farmers, without overlaps




# The minimum number of farmers (after extrapolation) supplying known cooperatives is  

```
In the public reports, in 2021, there was 
RA: 
126279 tonnes of RA cocoa sold from CIV (down 8% from 2020)
162270 tonnes of RA cocoa produced in CIV (down 15% from 2020)

442515 tonnes of UTZ cocoa sold from CIV (down 8% from 2020)
485797 tonnes of UTZ cocoa produced in CIV (down 15% from 2020)

That's an estimated 530k farmers. 
`r (162270+485797)/1.222``

 


## The different SSIs and their sizes
```{r, fig.width = 12, fig.height = 5}
# Plot the number of coops certified by certification program
ssi_2023 <- 
  coopbsy %>% 
  mutate(CERT1 = str_split(CERTIFICATIONS, " [+] ")) %>% 
  unnest(cols = c(CERT1)) %>%
  filter(!is.na(CERT1) & CERT1 != "" & CERT1 != "NA" & CERT1 != "9999") %>% 
  # filter out certification programs
  # filter(!(CERT1 %in% c("RAINFOREST ALLIANCE", "FAIRTRADE", "UTZ"))) %>% 
  
  # mutate(CERT1 = case_when(
  #   # Don't group UTZ and RFA (if not removed)
  #   # CERT1 == "UTZ" ~ "UTZ / RAINFOREST ALLIANCE",
  #   # CERT1 == "RAINFOREST ALLIANCE" ~ "UTZ / RAINFOREST ALLIANCE",
  #   CERT1 == "COCOA HORIZONS" ~ "COCOA HORIZONS (Barry Callebaut)",
  #   CERT1 == "COCOA LIFE" ~ "COCOA LIFE (Mondelez)",
  #   CERT1 == "COCOA PLAN" ~ "COCOA PLAN (Neslté)",
  #   CERT1 == "SUSTAINABLE ORIGINS" ~ "SUSTAINABLE ORIGINS (Blommer)",
  #   CERT1 == "CARGILL COCOA PROMISE" ~ "COCOA PROMISE (Cargill)",
  #   CERT1 == "CACAO-TRACE" ~ "CACAO-TRACE (Puratos)",
  #   CERT1 == "TRANSPARENCE CACAO" ~ "TRANSPARENCE CACAO (Cemoi)",
  #   CERT1 == "COCOA FOR GOOD" ~ "COCOA FOR GOOD (Hershey)",
  # 
  #   TRUE ~ CERT1
  # )) %>%
  filter(YEAR == 2023) %>% # 2023 has info from the past, if a coop was not disclosed anymore, or most recent info 
  summarise(NB_COOP = length(unique(COOP_ID)),
            NB_FARMER = sum(TOTAL_FARMERS, na.rm = TRUE),
            .by = c(CERT1)) 

ssi_2023$CERT1 <- 
  reorder(ssi_2023$CERT1, ssi_2023$NB_COOP, FUN = function(x) -mean(x))

ssi_2023$CERT1 

ggarrange(
  ggplot() +
    geom_col(data = ssi_2023, 
             width = 0.9, 
             aes(x = as.factor(CERT1), fill = CERT1, y = NB_COOP)) +
    scale_fill_manual(name = "", values = as.vector(alphabet())) +
    scale_x_discrete(labels = "", breaks = NULL) +
    labs(title = "Number of cooperatives",
      x = "", y = "") +
    theme_minimal(),
  
  ggplot() +
    geom_col(data = ssi_2023, 
             width = 0.9, 
             aes(x = as.factor(CERT1), fill = CERT1, y = NB_FARMER)) +
    scale_fill_manual(name = "", values = as.vector(alphabet())) +
    scale_x_discrete(labels = "", breaks = NULL) +
    scale_y_continuous(labels = unit_format(scale = 0.001, unit = "")) + 
    # geom_line(data = year_df1, aes(x = YEAR, y = Value), col = "black") +
    labs(title = "Thousand of farmers",
      x = "", y = "") +
    # guides(fill = guide_legend(nrow = 1, label.theme = element_text(angle = 30), label.position = "bottom", direction = "horizontal", label.vjust = -1, keywidth = 0.1)) +
  theme_minimal(),
  common.legend = TRUE, nrow = 1, ncol = 2, legend = "bottom"
) %>% 
  annotate_figure(top = text_grob("Minimum coverages of sustainable cocoa sourcing initiatives, Ivory Coast 2023 (not showing overlaps) \n", face = "bold", size = 15)) 
                  # fig.lab = "(not showing overlaps", fig.lab.pos = "top.left", fig.lab.size = 7)

```


## How much do SSIs and certification overlap? 

```{r, message = FALSE, fig.width = 12, fig.height = 8}
# Make categories of coops
# helper function that distinguishes SSIs from certification programs
fn_is_ssi <- function(x){
  !grepl("FAIRTRADE|RAINFOREST ALLIANCE|UTZ|OTHER PROGRAMMES OR CERTIFICATIONS", x) & x != ""
}

fn_is_certif <- function(x){
  grepl("FAIRTRADE|RAINFOREST ALLIANCE|UTZ|", x) 
}


unique(ssi_2023$CERT1)[fn_is_ssi(unique(ssi_2023$CERT1))]

camcy23_ssidumm <- 
 coopbsy %>% 
  filter(YEAR == 2023) %>% 
  mutate(CERT1 = str_split(CERTIFICATIONS, " [+] ")) %>% 
  unnest(cols = c(CERT1)) %>%
  group_by(COOP_ID) %>% 
  summarize(ANY_CERT_PROG = any(grepl("FAIRTRADE|RAINFOREST|UTZ", CERT1)),
             ANY_SSI = any(fn_is_ssi(CERT1)), 
             N_DIST_SSI = length(unique(CERT1[fn_is_ssi(CERT1)])), 
             SINGLE_SSI = N_DIST_SSI == 1,
             SVL_SSI = N_DIST_SSI > 1
    ) %>% 
  mutate(NOTHING = !ANY_CERT_PROG & !ANY_SSI,
         ONLY_CERT_PROG = ANY_CERT_PROG & !ANY_SSI,
         ANY_CERT_1_SSI = ANY_CERT_PROG & SINGLE_SSI, 
         ANY_CERT_SVL_SSI = ANY_CERT_PROG & SVL_SSI, 
         ONLY_1_SSI = !ANY_CERT_PROG & SINGLE_SSI, 
         ONLY_SVL_SSI = !ANY_CERT_PROG & SVL_SSI
        ) 

# data in adhoc format
combinations_cert_ssi <- 
  rbind(
    count(camcy23_ssidumm, ONLY_CERT_PROG) %>% 
      filter(ONLY_CERT_PROG) %>% mutate(ONLY_CERT_PROG = "Certification but no SSI") %>% rename(GROUP = ONLY_CERT_PROG),
    count(camcy23_ssidumm, ANY_CERT_1_SSI) %>% 
      filter(ANY_CERT_1_SSI) %>% mutate(ANY_CERT_1_SSI = "Certification & a single SSI") %>% rename(GROUP = ANY_CERT_1_SSI),
    count(camcy23_ssidumm, ANY_CERT_SVL_SSI) %>% 
      filter(ANY_CERT_SVL_SSI) %>% mutate(ANY_CERT_SVL_SSI = "Certification & several SSIS") %>% rename(GROUP = ANY_CERT_SVL_SSI),
    count(camcy23_ssidumm, ONLY_1_SSI) %>% 
      filter(ONLY_1_SSI) %>% mutate(ONLY_1_SSI = "No Certification & a single SSI") %>% rename(GROUP = ONLY_1_SSI),
    count(camcy23_ssidumm, ONLY_SVL_SSI) %>% 
      filter(ONLY_SVL_SSI) %>% mutate(ONLY_SVL_SSI = "No certification & several SSIs") %>% rename(GROUP = ONLY_SVL_SSI)
  ) %>% 
  # fix order of appearance
  mutate(GROUP = as.factor(GROUP))

# check mutual exclusivity
# combinations_cert_ssi$n %>% sum() + sum(camcy23_ssidumm$NOTHING) == nrow(camcy23_ssidumm)

combinations_cert_ssi$GROUP <- 
  reorder(combinations_cert_ssi$GROUP, c(5,4,3,2,1)*-1)


ggplot(data = combinations_cert_ssi, 
         aes(x = "", y = n, fill = GROUP)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  geom_text(aes(label = n), size = 7,
            position = position_stack(vjust = 0.5)) +
  coord_polar(theta = "y") +
  scale_fill_manual(name = "", values = trase_palettes[["categorical"]]) +
  labs(title = "Number of cooperatives by combinations of SSI and certification programs", subtitle = "Certification = Fairtrade or Rainforest Alliance/UTZ",
        x = "", y = "") +
  theme_void() +
  theme(
    legend.key.size = unit(1.5, "cm"),
    legend.text = element_text(size = 15),
    plot.title = element_text(
      face = "bold",
      size = 20
    ))


```

```{r}
# Most frequent combinations

```


